<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2.1 常见算法 on 算法学习笔记</title><link>https://kingye.me/study-algs/docs/advanced/common/</link><description>Recent content in 2.1 常见算法 on 算法学习笔记</description><generator>Hugo</generator><language>en</language><atom:link href="https://kingye.me/study-algs/docs/advanced/common/index.xml" rel="self" type="application/rss+xml"/><item><title>1.3.1 排序算法</title><link>https://kingye.me/study-algs/docs/advanced/common/sort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/common/sort/</guid><description>&lt;h1 id="排序算法">
 排序算法
 &lt;a class="anchor" href="#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95">#&lt;/a>
&lt;/h1>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200424114357.png" alt="" />&lt;/p></description></item><item><title>LRU Cache</title><link>https://kingye.me/study-algs/docs/advanced/common/lru/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/common/lru/</guid><description>&lt;h1 id="lru-cache">
 LRU Cache
 &lt;a class="anchor" href="#lru-cache">#&lt;/a>
&lt;/h1>
&lt;p>LRU 全称是 &lt;code>Least Recently Used&lt;/code>，即最近最久未使用的意思。&lt;/p>
&lt;p>LRU 算法的设计原则是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。
也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。&lt;/p>
&lt;h2 id="lru-k">
 LRU-K
 &lt;a class="anchor" href="#lru-k">#&lt;/a>
&lt;/h2>
&lt;p>LRU-K 中的 K 代表最近使用的次数，因此 LRU 可以认为是 LRU-1。&lt;/p>
&lt;p>LRU-K 的主要目的是为了解决 LRU 算法 “缓存污染” 的问题，
其核心思想是将 “最近使用过 1 次” 的判断标准扩展为 “最近使用过 K 次”。&lt;/p>
&lt;h2 id="redis-的-lru-实现">
 Redis 的 LRU 实现
 &lt;a class="anchor" href="#redis-%e7%9a%84-lru-%e5%ae%9e%e7%8e%b0">#&lt;/a>
&lt;/h2>
&lt;p>如果按照 HashMap 和双向链表实现，需要额外的存储存放 next 和 prev 指针，牺牲比较大的存储空间，显然是不划算的。所以 Redis 采用了一个近似的做法，就是随机取出若干个 key，然后按照访问时间排序后，淘汰掉最不经常使用的，具体分析如下：&lt;/p>
&lt;p>为了支持 LRU，Redis 2.8.19 中使用了一个全局的 LRU 时钟，&lt;code>server.lruclock&lt;/code>，定义如下，&lt;/p>
&lt;pre tabindex="0">&lt;code>#define REDIS_LRU_BITS 24
unsigned lruclock:REDIS_LRU_BITS; /* Clock for LRU eviction */
&lt;/code>&lt;/pre>&lt;p>默认的 LRU 时钟的分辨率是 1 秒，可以通过改变  &lt;code>REDIS_LRU_CLOCK_RESOLUTION&lt;/code>  宏的值来改变，Redis 会在  &lt;code>serverCron()&lt;/code>  中调用  &lt;code>updateLRUClock&lt;/code>  定期的更新 LRU 时钟，更新的频率和 hz 参数有关，默认为  &lt;code>100ms&lt;/code>  一次，如下，&lt;/p></description></item><item><title>paxos</title><link>https://kingye.me/study-algs/docs/advanced/common/paxos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/common/paxos/</guid><description>&lt;h1 id="paxos">
 paxos
 &lt;a class="anchor" href="#paxos">#&lt;/a>
&lt;/h1></description></item><item><title>raft</title><link>https://kingye.me/study-algs/docs/advanced/common/raft/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/common/raft/</guid><description>&lt;h1 id="raft">
 raft
 &lt;a class="anchor" href="#raft">#&lt;/a>
&lt;/h1></description></item><item><title>树</title><link>https://kingye.me/study-algs/docs/advanced/common/tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/common/tree/</guid><description>&lt;h1 id="树">
 树
 &lt;a class="anchor" href="#%e6%a0%91">#&lt;/a>
&lt;/h1>
&lt;h2 id="判断一棵树是否包含另一棵树的结构">
 判断一棵树是否包含另一棵树的结构
 &lt;a class="anchor" href="#%e5%88%a4%e6%96%ad%e4%b8%80%e6%a3%b5%e6%a0%91%e6%98%af%e5%90%a6%e5%8c%85%e5%90%ab%e5%8f%a6%e4%b8%80%e6%a3%b5%e6%a0%91%e7%9a%84%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h2>
&lt;p>使用树结构序列化的方法，将两棵树进行相同方式的序列化，然后利用 &lt;strong>kmp&lt;/strong> 判断子串，则可以得到&lt;/p>
&lt;p>结果，时间复杂度为 O（m+n）&lt;/p>
&lt;p>这道题的可行性是：&lt;strong>树结构的序列化和反序列化是一一对应的&lt;/strong>&lt;/p>
&lt;hr></description></item><item><title>KMP</title><link>https://kingye.me/study-algs/docs/advanced/common/kmp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/common/kmp/</guid><description>&lt;h1 id="kmp">
 KMP
 &lt;a class="anchor" href="#kmp">#&lt;/a>
&lt;/h1>
&lt;p>KMP 是用来找字符串匹配的&lt;/p>
&lt;p>KMP 的时间复杂度是 O (m + n)&lt;/p>
&lt;h2 id="参考">
 参考
 &lt;a class="anchor" href="#%e5%8f%82%e8%80%83">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.zhihu.com/question/21923021">如何更好地理解和掌握 KMP 算法？&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/83334559">KMP 算法详解&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.inf.hs-flensburg.de/lang/algorithmen/pattern/kmpen.htm">Knuth-Morris-Pratt algorithm&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/112861530">KMP：花 48 小时看懂了 KMP，想让你在 48 分钟内看懂&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>布隆过滤器</title><link>https://kingye.me/study-algs/docs/advanced/common/bloom/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/common/bloom/</guid><description>&lt;h1 id="布隆过滤器httpswwwwikiwandcomzh-cne5b883e99a86e8bf87e6bba4e599a8">
 &lt;a href="https://www.wikiwand.com/zh-cn/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8">布隆过滤器&lt;/a>
 &lt;a class="anchor" href="#%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8httpswwwwikiwandcomzh-cne5b883e99a86e8bf87e6bba4e599a8">#&lt;/a>
&lt;/h1>
&lt;p>布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。
它实际上是一个&lt;strong>很长的二进制向量&lt;/strong>和&lt;strong>一系列随机映射函数&lt;/strong>。
布隆过滤器可以用于检索一个元素是否在一个集合中。
它的优点是&lt;strong>空间效率&lt;/strong>和&lt;strong>查询时间&lt;/strong>都比一般的算法要好的多，
缺点是有一定的&lt;strong>误识别率&lt;/strong>和&lt;strong>删除困难&lt;/strong>。&lt;/p>
&lt;p>解决：
网页 URL 去重、垃圾邮件识别、大集合中重复元素的判断和缓存穿透等问题&lt;/p>
&lt;p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你
某样东西&lt;strong>一定不存在&lt;/strong>或者&lt;strong>可能存在&lt;/strong>。&lt;/p>
&lt;p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。&lt;/p>
&lt;h2 id="hashmap-的问题">
 HashMap 的问题
 &lt;a class="anchor" href="#hashmap-%e7%9a%84%e9%97%ae%e9%a2%98">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能&lt;strong>一次性读进内存&lt;/strong>构建 HashMap 的时候，也会存在问题。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="布隆过滤器的原理">
 布隆过滤器的原理
 &lt;a class="anchor" href="#%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8%e7%9a%84%e5%8e%9f%e7%90%86">#&lt;/a>
&lt;/h2>
&lt;p>当一个元素被加入集合时，通过 K 个&lt;a href="https://www.wikiwand.com/zh-cn/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0">散列函数&lt;/a>将这个元素映射成一个位&lt;a href="https://www.wikiwand.com/zh-cn/%E6%95%B0%E7%BB%84" title="数组">数组&lt;/a>中的 K 个点，把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在。&lt;/p>
&lt;hr>
&lt;h2 id="应用">
 应用
 &lt;a class="anchor" href="#%e5%ba%94%e7%94%a8">#&lt;/a>
&lt;/h2>
&lt;p>在大数据场景应用比较多，比如 Hbase 中使用它去判断数据是否在磁盘上。&lt;/p>
&lt;p>还有在爬虫场景判断 url 是否已经被爬取过。&lt;/p>
&lt;h3 id="在缓存之前在加一层-bloomfilter">
 在缓存之前在加一层 BloomFilter
 &lt;a class="anchor" href="#%e5%9c%a8%e7%bc%93%e5%ad%98%e4%b9%8b%e5%89%8d%e5%9c%a8%e5%8a%a0%e4%b8%80%e5%b1%82-bloomfilter">#&lt;/a>
&lt;/h3></description></item></channel></rss>