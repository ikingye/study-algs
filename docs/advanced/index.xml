<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>第二部分 进阶 on 算法学习笔记</title>
    <link>https://ikingye.github.io/study-algs/docs/advanced/</link>
    <description>Recent content in 第二部分 进阶 on 算法学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://ikingye.github.io/study-algs/docs/advanced/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>KMP</title>
      <link>https://ikingye.github.io/study-algs/docs/advanced/kmp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-algs/docs/advanced/kmp/</guid>
      <description>KMP KMP 是用来找字符串匹配的
KMP 的时间复杂度是 O (m + n)
参考  如何更好地理解和掌握 KMP 算法？ KMP 算法详解 Knuth-Morris-Pratt algorithm  KMP：花 48 小时看懂了 KMP，想让你在 48 分钟内看懂    </description>
    </item>
    
    <item>
      <title>raft</title>
      <link>https://ikingye.github.io/study-algs/docs/advanced/raft/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-algs/docs/advanced/raft/</guid>
      <description>raft 关注 baidu/braft  </description>
    </item>
    
    <item>
      <title>布隆过滤器</title>
      <link>https://ikingye.github.io/study-algs/docs/advanced/bloom-filter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-algs/docs/advanced/bloom-filter/</guid>
      <description>布隆过滤器 布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。 它实际上是一个很长的二进制向量和一系列随机映射函数。 布隆过滤器可以用于检索一个元素是否在一个集合中。 它的优点是空间效率和查询时间都比一般的算法要好的多， 缺点是有一定的误识别率和删除困难。
解决： 网页 URL 去重、垃圾邮件识别、大集合中重复元素的判断和缓存穿透等问题
本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 某样东西一定不存在或者可能存在。
相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。
HashMap 的问题   例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。
  还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能一次性读进内存构建 HashMap 的时候，也会存在问题。
  布隆过滤器的原理 当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在。
 应用 在大数据场景应用比较多，比如 Hbase 中使用它去判断数据是否在磁盘上。
还有在爬虫场景判断 url 是否已经被爬取过。
在缓存之前在加一层 BloomFilter </description>
    </item>
    
  </channel>
</rss>