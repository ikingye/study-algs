<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法设计 on 算法学习笔记</title>
    <link>https://ikingye.github.io/study-algs/docs/practice/design/</link>
    <description>Recent content in 算法设计 on 算法学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://ikingye.github.io/study-algs/docs/practice/design/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LRU Cache</title>
      <link>https://ikingye.github.io/study-algs/docs/practice/design/lru/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ikingye.github.io/study-algs/docs/practice/design/lru/</guid>
      <description>LRU Cache LRU 全称是 Least Recently Used，即最近最久未使用的意思。
LRU 算法的设计原则是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。 也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。
LRU-K LRU-K 中的 K 代表最近使用的次数，因此 LRU 可以认为是 LRU-1。
LRU-K 的主要目的是为了解决 LRU 算法 “缓存污染” 的问题， 其核心思想是将 “最近使用过 1 次” 的判断标准扩展为 “最近使用过 K 次”。
Redis 的 LRU 实现 如果按照 HashMap 和双向链表实现，需要额外的存储存放 next 和 prev 指针，牺牲比较大的存储空间，显然是不划算的。所以 Redis 采用了一个近似的做法，就是随机取出若干个 key，然后按照访问时间排序后，淘汰掉最不经常使用的，具体分析如下：
为了支持 LRU，Redis 2.8.19 中使用了一个全局的 LRU 时钟，server.lruclock，定义如下，
#define REDIS_LRU_BITS 24 unsigned lruclock:REDIS_LRU_BITS; /* Clock for LRU eviction */ 默认的 LRU 时钟的分辨率是 1 秒，可以通过改变 REDIS_LRU_CLOCK_RESOLUTION 宏的值来改变，Redis 会在 serverCron() 中调用 updateLRUClock 定期的更新 LRU 时钟，更新的频率和 hz 参数有关，默认为 100ms 一次，如下，</description>
    </item>
    
  </channel>
</rss>