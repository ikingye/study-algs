'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':4,'href':'/study-algs/docs/basic/datastruct/','title':"1.1 数据结构",'section':"第一部分 基础入门",'content':"数据结构 #  常用的数据结构 #   数组（Array） 堆栈（Stack） 队列（Queue） 链表（Linked List） 树（Tree） 图（Graph） 堆积（Heap） 散列表（Hash table）   数据结构定义（源码） #  栈 #  C C\u0026#43;\u0026#43; C# Go stack := make([]int, 0) // push 入栈 stack = append(stack, 3) // pop 出栈 v := stack[len(stack) - 1] stack = stack[: len(stack) - 1] // 判断栈为空 if len(stack) == 0 { } Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift   队列 #  C C\u0026#43;\u0026#43; C# Go queue := make([]int, 0) // enqueue 入队 queue = append(queue, 5) // dequeue 出队 v := queue[0] queue = queue[1:] // 判断长度为 0 if len(queue) == 0 { } Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift   链表 (Linked List) #  单向链表 节点 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 # Definition for singly-linked list. class ListNode(object): def __init__(self, val): self.val = val self.next = None Python3 # Definition for singly-linked list. class ListNode: def __init__(self, val): self.val = val self.next = None Ruby Rust Scala Swift   双向链表 节点 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 # Definition for doubly-linked list. class ListNode(object): def __init__(self, val): self.val = val self.pre = None self.next = None Python3 # Definition for doubly-linked list. class ListNode: def __init__(self, val): self.val = val self.pre = None self.next = None Ruby Rust Scala Swift   树 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 # Definition for a binary tree node class TreeNode(object) { def __init__(self, val): self.val = val self.left = None self.right = None } Python3 # Definition for a binary tree node class TreeNode { def __init__(self, val): self.val = val self.left = None self.right = None } Ruby Rust Scala Swift   数据结构列表 #  \n类型 #   集合 容器  抽象类型 #   关联数组  多重关连数组（英语：Multimap）   列表 堆栈 队列  双端队列   优先队列  双端优先队列（英语：Double-ended priority queue）   集合  多重集 并查集    数组 #   字符串 位数组（英语：Bit array） 环形缓冲器 动态数组（英语：Dynamic array） 哈希表 哈希数组树（英语：Hashed array tree） 稀疏矩阵  链 #  Linked data structure\n 关联表（英语：Association list） 链表 跳跃列表 松散链表（英语：Unrolled linked list） 异或链表  树 #   线段树 自平衡二叉查找树 B 树 二叉树  AA 树 AVL 树 红黑树 平衡树 伸展树 二叉查找树   堆  二叉堆 左偏树 二项堆 斐波那契堆   R 树  R * 树 R + 树 Hilbert R 树（英语：Hilbert R-tree）   前缀树  哈希树    图 #   有向图 有向无环图 二元决策图 无向图 确定性非循环有限自动机  "});index.add({'id':5,'href':'/study-algs/docs/advanced/common/sort/','title':"1.3.1 排序算法",'section':"2.1 常见算法",'content':"排序算法 #  "});index.add({'id':6,'href':'/study-algs/docs/advanced/common/','title':"2.1 常见算法",'section':"第二部分 进阶实战",'content':"常见算法 #  "});index.add({'id':7,'href':'/study-algs/docs/appendix/tutorial/','title':"4.1 教程",'section':"第四部分 附录",'content':"算法教程 #  基础 #  labuladong/fucking-algorithm #  手把手撕 LeetCode 题目，扒各种算法套路的裤子， not only how，but also why. English version supported! https://labuladong.gitbook.io/algo/\ndonnemartin/interactive-coding-challenges #  120+ interactive Python coding interview challenges (algorithms and data structures). Includes Anki flashcards.\n(book)kevin-wayne/algs4 #  Algorithms, 4th edition textbook code and libraries\n 进阶 #  "});index.add({'id':8,'href':'/study-algs/docs/advanced/common/lru/','title':"LRU Cache",'section':"2.1 常见算法",'content':"LRU Cache #  LRU 全称是 Least Recently Used，即最近最久未使用的意思。\nLRU 算法的设计原则是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。 也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。\nLRU-K #  LRU-K 中的 K 代表最近使用的次数，因此 LRU 可以认为是 LRU-1。\nLRU-K 的主要目的是为了解决 LRU 算法 “缓存污染” 的问题， 其核心思想是将 “最近使用过 1 次” 的判断标准扩展为 “最近使用过 K 次”。\nRedis 的 LRU 实现 #  如果按照 HashMap 和双向链表实现，需要额外的存储存放 next 和 prev 指针，牺牲比较大的存储空间，显然是不划算的。所以 Redis 采用了一个近似的做法，就是随机取出若干个 key，然后按照访问时间排序后，淘汰掉最不经常使用的，具体分析如下：\n为了支持 LRU，Redis 2.8.19 中使用了一个全局的 LRU 时钟，server.lruclock，定义如下，\n#define REDIS_LRU_BITS 24 unsigned lruclock:REDIS_LRU_BITS; /* Clock for LRU eviction */ 默认的 LRU 时钟的分辨率是 1 秒，可以通过改变 REDIS_LRU_CLOCK_RESOLUTION 宏的值来改变，Redis 会在 serverCron() 中调用 updateLRUClock 定期的更新 LRU 时钟，更新的频率和 hz 参数有关，默认为 100ms 一次，如下，\n#define REDIS_LRU_CLOCK_MAX ((1\u0026lt;\u0026lt;REDIS_LRU_BITS)-1) /* Max value of obj-\u0026gt;lru */ #define REDIS_LRU_CLOCK_RESOLUTION 1 /* LRU clock resolution in seconds */ void updateLRUClock(void) { server.lruclock = (server.unixtime / REDIS_LRU_CLOCK_RESOLUTION) \u0026amp; REDIS_LRU_CLOCK_MAX; } server.unixtime 是系统当前的 unix 时间戳，当 lruclock 的值超出 REDIS_LRU_CLOCK_MAX 时，会从头开始计算，所以在计算一个 key 的最长没有访问时间时，可能 key 本身保存的 lru 访问时间会比当前的 lrulock 还要大，这个时候需要计算额外时间，如下，\n/* Given an object returns the min number of seconds the object was never * requested, using an approximated LRU algorithm. */ unsigned long estimateObjectIdleTime(robj *o) { if (server.lruclock \u0026gt;= o-\u0026gt;lru) { return (server.lruclock - o-\u0026gt;lru) * REDIS_LRU_CLOCK_RESOLUTION; } else { return ((REDIS_LRU_CLOCK_MAX - o-\u0026gt;lru) + server.lruclock) * REDIS_LRU_CLOCK_RESOLUTION; } } Redis 支持和 LRU 相关淘汰策略包括，\n volatile-lru 设置了过期时间的 key 参与近似的 lru 淘汰策略 allkeys-lru 所有的 key 均参与近似的 lru 淘汰策略  当进行 LRU 淘汰时，Redis 按如下方式进行的，\n...... /* volatile-lru and allkeys-lru policy */ else if (server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_LRU || server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_LRU) { for (k = 0; k \u0026lt; server.maxmemory_samples; k++) { sds thiskey; long thisval; robj *o; de = dictGetRandomKey(dict); thiskey = dictGetKey(de); /* When policy is volatile-lru we need an additional lookup * to locate the real key, as dict is set to db-\u0026gt;expires. */ if (server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_LRU) de = dictFind(db-\u0026gt;dict, thiskey); o = dictGetVal(de); thisval = estimateObjectIdleTime(o); /* Higher idle time is better candidate for deletion */ if (bestkey == NULL || thisval \u0026gt; bestval) { bestkey = thiskey; bestval = thisval; } } } ...... Redis 会基于 server.maxmemory_samples 配置选取固定数目的 key，然后比较它们的 lru 访问时间，然后淘汰最近最久没有访问的 key，maxmemory_samples 的值越大，Redis 的近似 LRU 算法就越接近于严格 LRU 算法，但是相应消耗也变高，对性能有一定影响，样本值默认为 5。\n总结\n看来，虽然一个简单的概念，在工业界的产品中，为了追求空间的利用率，也会采用权衡的实现方案。\n参考 #   LeetCode: LRU 缓存机制 LRU 原理和 Redis 实现 —— 一个今日头条的面试题  "});index.add({'id':9,'href':'/study-algs/docs/advanced/common/paxos/','title':"paxos",'section':"2.1 常见算法",'content':"paxos #  "});index.add({'id':10,'href':'/study-algs/docs/advanced/common/raft/','title':"raft",'section':"2.1 常见算法",'content':"raft #  "});index.add({'id':11,'href':'/study-algs/docs/advanced/common/tree/','title':"树",'section':"2.1 常见算法",'content':"树 #  判断一棵树是否包含另一棵树的结构 #  使用树结构序列化的方法，将两棵树进行相同方式的序列化，然后利用 kmp 判断子串，则可以得到\n结果，时间复杂度为 O（m+n）\n这道题的可行性是：树结构的序列化和反序列化是一一对应的\n "});index.add({'id':12,'href':'/study-algs/docs/basic/thought/','title':"1.2 算法思想",'section':"第一部分 基础入门",'content':"算法思想 #  基本算法 #  递归 #   迭代 #   贪心 / 贪婪 #   动态规划 #   分治 #  分治算法是递归的典型应用\n 回溯法 backtracking #  回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。\n回溯法简单来说就是按照深度优先的顺序，穷举所有可能性的算法， 但是回溯算法比暴力穷举法更高明的地方就是回溯算法可以随时判断当前状态是否符合问题的条件。 一旦不符合条件，那么就退回到上一个状态，省去了继续往下探索的时间。\n 分支限界法 #  分支限界法是广度优先的一个经典例子\n 其他 #  背包 #  "});index.add({'id':13,'href':'/study-algs/docs/advanced/leetcode/','title':"2.2 LeetCode",'section':"第二部分 进阶实战",'content':"LeetCode 学习笔记 #  见：LeetCode 学习笔记\n"});index.add({'id':14,'href':'/study-algs/docs/appendix/interview/','title':"4.2 面试题",'section':"第四部分 附录",'content':"算法面试题 #  基础题 #  进阶题 #  "});index.add({'id':15,'href':'/study-algs/docs/advanced/common/kmp/','title':"KMP",'section':"2.1 常见算法",'content':"KMP #  KMP 是用来找字符串匹配的\nKMP 的时间复杂度是 O (m + n)\n参考 #   如何更好地理解和掌握 KMP 算法？ KMP 算法详解 Knuth-Morris-Pratt algorithm  KMP：花 48 小时看懂了 KMP，想让你在 48 分钟内看懂    "});index.add({'id':16,'href':'/study-algs/docs/advanced/common/bloom/','title':"布隆过滤器",'section':"2.1 常见算法",'content':"布隆过滤器 #  布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。 它实际上是一个很长的二进制向量和一系列随机映射函数。 布隆过滤器可以用于检索一个元素是否在一个集合中。 它的优点是空间效率和查询时间都比一般的算法要好的多， 缺点是有一定的误识别率和删除困难。\n解决： 网页 URL 去重、垃圾邮件识别、大集合中重复元素的判断和缓存穿透等问题\n本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 某样东西一定不存在或者可能存在。\n相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。\nHashMap 的问题 #    例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。\n  还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能一次性读进内存构建 HashMap 的时候，也会存在问题。\n  布隆过滤器的原理 #  当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在。\n 应用 #  在大数据场景应用比较多，比如 Hbase 中使用它去判断数据是否在磁盘上。\n还有在爬虫场景判断 url 是否已经被爬取过。\n在缓存之前在加一层 BloomFilter #  "});index.add({'id':17,'href':'/study-algs/docs/basic/thought/recursive/','title':"递归",'section':"1.2 算法思想",'content':"递归 #  参考 #   三道题套路解决递归问题  "});index.add({'id':18,'href':'/study-algs/docs/advanced/nowcoder/','title':"2.3 牛客网",'section':"第二部分 进阶实战",'content':"牛客网 #  "});index.add({'id':19,'href':'/study-algs/docs/appendix/attention/','title':"4.3 关注项目",'section':"第四部分 附录",'content':"关注项目 #  "});})();