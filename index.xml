<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>首页 on 算法学习笔记</title><link>https://kingye.me/study-algs/</link><description>Recent content in 首页 on 算法学习笔记</description><generator>Hugo</generator><language>en</language><atom:link href="https://kingye.me/study-algs/index.xml" rel="self" type="application/rss+xml"/><item><title>1. 两数之和</title><link>https://kingye.me/study-algs/docs/advanced/leetcode/0/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/leetcode/0/1/</guid><description>&lt;h1 id="两数之和">
 两数之和
 &lt;a class="anchor" href="#%e4%b8%a4%e6%95%b0%e4%b9%8b%e5%92%8c">#&lt;/a>
&lt;/h1>
&lt;h2 id="题目httpsleetcode-cncomproblemstwo-sum">
 &lt;a href="https://leetcode-cn.com/problems/two-sum">题目&lt;/a>
 &lt;a class="anchor" href="#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemstwo-sum">#&lt;/a>
&lt;/h2>




&lt;div class="book-tabs">&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-0" checked="checked" />
 &lt;label for="tabs-leetcode-problem-0">中文&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>给定一个整数数组 nums  和一个目标值 target，请你在该数组中找出和为目标值的那&lt;strong>两个&lt;/strong>整数，并返回他们的数组下标。&lt;/p>
&lt;p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p>
&lt;p>示例:&lt;/p>
&lt;pre tabindex="0">&lt;code>给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
&lt;/code>&lt;/pre>&lt;/div>&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-1" />
 &lt;label for="tabs-leetcode-problem-1">English&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.&lt;/p>
&lt;p>You may assume that each input would have exactly one solution, and you may not use the same element twice.&lt;/p></description></item><item><title>2. 两数相加</title><link>https://kingye.me/study-algs/docs/advanced/leetcode/0/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/leetcode/0/2/</guid><description>&lt;h1 id="两数相加">
 两数相加
 &lt;a class="anchor" href="#%e4%b8%a4%e6%95%b0%e7%9b%b8%e5%8a%a0">#&lt;/a>
&lt;/h1>
&lt;h2 id="题目httpsleetcode-cncomproblemsadd-two-numbers">
 &lt;a href="https://leetcode-cn.com/problems/add-two-numbers/">题目&lt;/a>
 &lt;a class="anchor" href="#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemsadd-two-numbers">#&lt;/a>
&lt;/h2>




&lt;div class="book-tabs">&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-0" checked="checked" />
 &lt;label for="tabs-leetcode-problem-0">中文&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>给出两个   非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照   逆序   的方式存储的，并且它们的每个节点只能存储   一位   数字。&lt;/p>
&lt;p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&lt;/p>
&lt;p>您可以假设除了数字 0 之外，这两个数都不会以 0  开头。&lt;/p>
&lt;p>示例：&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：(2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
输出：7 -&amp;gt; 0 -&amp;gt; 8
原因：342 + 465 = 807
&lt;/code>&lt;/pre>&lt;/div>&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-1" />
 &lt;label for="tabs-leetcode-problem-1">English&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.&lt;/p></description></item><item><title>3. 无重复字符的最长子串</title><link>https://kingye.me/study-algs/docs/advanced/leetcode/0/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/leetcode/0/3/</guid><description>&lt;h1 id="无重复字符的最长子串">
 无重复字符的最长子串
 &lt;a class="anchor" href="#%e6%97%a0%e9%87%8d%e5%a4%8d%e5%ad%97%e7%ac%a6%e7%9a%84%e6%9c%80%e9%95%bf%e5%ad%90%e4%b8%b2">#&lt;/a>
&lt;/h1>
&lt;h2 id="题目httpsleetcode-cncomproblemslongest-substring-without-repeating-characters">
 &lt;a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">题目&lt;/a>
 &lt;a class="anchor" href="#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemslongest-substring-without-repeating-characters">#&lt;/a>
&lt;/h2>




&lt;div class="book-tabs">&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-0" checked="checked" />
 &lt;label for="tabs-leetcode-problem-0">中文&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>给定一个字符串，请你找出其中不含有重复字符的   最长子串   的长度。&lt;/p>
&lt;p>示例  1:&lt;/p>
&lt;pre tabindex="0">&lt;code>输入: &amp;#34;abcabcbb&amp;#34;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;#34;abc&amp;#34;，所以其长度为 3。
&lt;/code>&lt;/pre>&lt;p>示例 2:&lt;/p>
&lt;pre tabindex="0">&lt;code>输入: &amp;#34;bbbbb&amp;#34;
输出: 1
解释: 因为无重复字符的最长子串是 &amp;#34;b&amp;#34;，所以其长度为 1。
&lt;/code>&lt;/pre>&lt;p>示例 3:&lt;/p>
&lt;pre tabindex="0">&lt;code>输入: &amp;#34;pwwkew&amp;#34;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;#34;wke&amp;#34;，所以其长度为 3。
  请注意，你的答案必须是 子串 的长度，&amp;#34;pwke&amp;#34; 是一个子序列，不是子串。
&lt;/code>&lt;/pre>&lt;/div>&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-1" />
 &lt;label for="tabs-leetcode-problem-1">English&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>Given a string, find the length of the longest substring without repeating characters.&lt;/p>
&lt;p>Example 1:&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: &amp;#34;abcabcbb&amp;#34;
Output: 3
Explanation: The answer is &amp;#34;abc&amp;#34;, with the length of 3.
&lt;/code>&lt;/pre>&lt;p>Example 2:&lt;/p></description></item><item><title>4. 寻找两个有序数组的中位数</title><link>https://kingye.me/study-algs/docs/advanced/leetcode/0/4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/leetcode/0/4/</guid><description>&lt;h1 id="寻找两个有序数组的中位数">
 寻找两个有序数组的中位数
 &lt;a class="anchor" href="#%e5%af%bb%e6%89%be%e4%b8%a4%e4%b8%aa%e6%9c%89%e5%ba%8f%e6%95%b0%e7%bb%84%e7%9a%84%e4%b8%ad%e4%bd%8d%e6%95%b0">#&lt;/a>
&lt;/h1>
&lt;h2 id="题目httpsleetcode-cncomproblemsmedian-of-two-sorted-arrays">
 &lt;a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">题目&lt;/a>
 &lt;a class="anchor" href="#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemsmedian-of-two-sorted-arrays">#&lt;/a>
&lt;/h2>




&lt;div class="book-tabs">&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-0" checked="checked" />
 &lt;label for="tabs-leetcode-problem-0">中文&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>给定两个大小为 m 和 n 的有序数组  nums1 和  nums2。&lt;/p>
&lt;p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为  O (log (m + n))。&lt;/p>
&lt;p>你可以假设  nums1  和  nums2  不会同时为空。&lt;/p>
&lt;p>示例 1:&lt;/p>
&lt;pre tabindex="0">&lt;code>nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
&lt;/code>&lt;/pre>&lt;p>示例 2:&lt;/p>
&lt;pre tabindex="0">&lt;code>nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
&lt;/code>&lt;/pre>&lt;/div>&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-1" />
 &lt;label for="tabs-leetcode-problem-1">English&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>There are two sorted arrays nums1 and nums2 of size m and n respectively.&lt;/p>
&lt;p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).&lt;/p></description></item><item><title>7. 整数反转</title><link>https://kingye.me/study-algs/docs/advanced/leetcode/0/7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/leetcode/0/7/</guid><description>&lt;h1 id="整数反转">
 整数反转
 &lt;a class="anchor" href="#%e6%95%b4%e6%95%b0%e5%8f%8d%e8%bd%ac">#&lt;/a>
&lt;/h1>
&lt;h2 id="题目httpsleetcode-cncomproblemsreverse-integer">
 &lt;a href="https://leetcode-cn.com/problems/reverse-integer/">题目&lt;/a>
 &lt;a class="anchor" href="#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemsreverse-integer">#&lt;/a>
&lt;/h2>




&lt;div class="book-tabs">&lt;input type="radio" class="toggle" name="tabs-leetcode-problem-1" id="tabs-leetcode-problem-1-0" checked="checked" />
 &lt;label for="tabs-leetcode-problem-1-0">中文&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p>
&lt;p>示例  1:&lt;/p>
&lt;pre tabindex="0">&lt;code>输入: 123
输出: 321
&lt;/code>&lt;/pre>&lt;p>示例 2:&lt;/p>
&lt;pre tabindex="0">&lt;code>输入: -123
输出: -321
&lt;/code>&lt;/pre>&lt;p>示例 3:&lt;/p>
&lt;pre tabindex="0">&lt;code>输入: 120
输出: 21
&lt;/code>&lt;/pre>&lt;p>注意:&lt;/p>
&lt;p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为&lt;/p>
&lt;link rel="stylesheet" href="https://kingye.me/study-algs/study-algs/katex/katex.min.css" />
&lt;script defer src="https://kingye.me/study-algs/study-algs/katex/katex.min.js">&lt;/script>
&lt;script defer src="https://kingye.me/study-algs/study-algs/katex/auto-render.min.js" onload="renderMathInElement(document.body, {
 delimiters: [
 {left: '$$', right: '$$', display: true},
 {left: '\\[', right: '\\]', display: true},
 {left: '$', right: '$', display: false},
 {left: '\\(', right: '\\)', display: false}
 ]
});">&lt;/script>&lt;span>
 \([-2^31, 2^31-1]。\)
&lt;/span>
&lt;p>请根据这个假设，如果反转后整数溢出那么就返回 0。&lt;/p>
&lt;/div>&lt;input type="radio" class="toggle" name="tabs-leetcode-problem-1" id="tabs-leetcode-problem-1-1" />
 &lt;label for="tabs-leetcode-problem-1-1">English&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>Given a 32-bit signed integer, reverse digits of an integer.&lt;/p></description></item><item><title>9. 回文数</title><link>https://kingye.me/study-algs/docs/advanced/leetcode/0/9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/leetcode/0/9/</guid><description>&lt;h1 id="回文数">
 回文数
 &lt;a class="anchor" href="#%e5%9b%9e%e6%96%87%e6%95%b0">#&lt;/a>
&lt;/h1>
&lt;h2 id="题目httpsleetcode-cncomproblemspalindrome-number">
 &lt;a href="https://leetcode-cn.com/problems/palindrome-number/">题目&lt;/a>
 &lt;a class="anchor" href="#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemspalindrome-number">#&lt;/a>
&lt;/h2>




&lt;div class="book-tabs">&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-0" checked="checked" />
 &lt;label for="tabs-leetcode-problem-0">中文&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p>
&lt;p>示例 1:&lt;/p>
&lt;pre tabindex="0">&lt;code>输入: 121
输出: true
&lt;/code>&lt;/pre>&lt;p>示例  2:&lt;/p>
&lt;pre tabindex="0">&lt;code>输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
&lt;/code>&lt;/pre>&lt;p>示例 3:&lt;/p>
&lt;pre tabindex="0">&lt;code>输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
&lt;/code>&lt;/pre>&lt;p>进阶:&lt;/p>
&lt;p>你能不将整数转为字符串来解决这个问题吗？&lt;/p>
&lt;/div>&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-1" />
 &lt;label for="tabs-leetcode-problem-1">English&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.&lt;/p>
&lt;p>Example 1:&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: 121
Output: true
&lt;/code>&lt;/pre>&lt;p>Example 2:&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
&lt;/code>&lt;/pre>&lt;p>Example 3:&lt;/p></description></item><item><title>1.3.1 排序算法</title><link>https://kingye.me/study-algs/docs/advanced/common/sort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/common/sort/</guid><description>&lt;h1 id="排序算法">
 排序算法
 &lt;a class="anchor" href="#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95">#&lt;/a>
&lt;/h1>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200424114357.png" alt="" />&lt;/p></description></item><item><title>10. 正则表达式匹配</title><link>https://kingye.me/study-algs/docs/advanced/leetcode/0/10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/leetcode/0/10/</guid><description>&lt;h1 id="正则表达式匹配">
 正则表达式匹配
 &lt;a class="anchor" href="#%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%8c%b9%e9%85%8d">#&lt;/a>
&lt;/h1>
&lt;h2 id="题目httpsleetcode-cncomproblemstwo-sum">
 &lt;a href="https://leetcode-cn.com/problems/two-sum">题目&lt;/a>
 &lt;a class="anchor" href="#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemstwo-sum">#&lt;/a>
&lt;/h2>




&lt;div class="book-tabs">&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-0" checked="checked" />
 &lt;label for="tabs-leetcode-problem-0">中文&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>给你一个字符串  s  和一个字符规律  p，请你来实现一个支持 &amp;lsquo;.&amp;rsquo;  和  &amp;lsquo;*&amp;rsquo;  的正则表达式匹配。&lt;/p>
&lt;p>&amp;lsquo;.&amp;rsquo; 匹配任意单个字符
&amp;lsquo;*&amp;rsquo; 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖   整个   字符串  s 的，而不是部分字符串。&lt;/p>
&lt;p>说明:&lt;/p>
&lt;p>s  可能为空，且只包含从  a-z  的小写字母。
p  可能为空，且只包含从  a-z  的小写字母，以及字符  .  和  *。
示例 1:&lt;/p>
&lt;pre tabindex="0">&lt;code>输入:
s = &amp;#34;aa&amp;#34;
p = &amp;#34;a&amp;#34;
输出: false
解释: &amp;#34;a&amp;#34; 无法匹配 &amp;#34;aa&amp;#34; 整个字符串。
&lt;/code>&lt;/pre>&lt;p>示例 2:&lt;/p>
&lt;pre tabindex="0">&lt;code>输入:
s = &amp;#34;aa&amp;#34;
p = &amp;#34;a*&amp;#34;
输出: true
解释: 因为 &amp;#39;*&amp;#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &amp;#39;a&amp;#39;。因此，字符串 &amp;#34;aa&amp;#34; 可被视为 &amp;#39;a&amp;#39; 重复了一次。
&lt;/code>&lt;/pre>&lt;p>示例  3:&lt;/p></description></item><item><title>4.1 教程</title><link>https://kingye.me/study-algs/docs/appendix/tutorial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/appendix/tutorial/</guid><description>&lt;h1 id="算法教程">
 算法教程
 &lt;a class="anchor" href="#%e7%ae%97%e6%b3%95%e6%95%99%e7%a8%8b">#&lt;/a>
&lt;/h1>
&lt;h2 id="基础">
 基础
 &lt;a class="anchor" href="#%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h2>
&lt;h3 id="labuladongfucking-algorithmhttpsgithubcomlabuladongfucking-algorithm-github-starshttpsimgshieldsiogithubstarslabuladongfucking-algorithmsvg-languagehttpsimgshieldsiogithublanguagestoplabuladongfucking-algorithmsvg-last-taghttpsimgshieldsiogithubvtaglabuladongfucking-algorithmsvgsortsemver-last-commithttpsimgshieldsiogithublast-commitlabuladongfucking-algorithmsvg">
 &lt;a href="https://github.com/labuladong/fucking-algorithm">labuladong/fucking-algorithm&lt;/a> &lt;img src="https://img.shields.io/github/stars/labuladong/fucking-algorithm.svg" alt="Github stars" /> &lt;img src="https://img.shields.io/github/languages/top/labuladong/fucking-algorithm.svg" alt="Language" /> &lt;img src="https://img.shields.io/github/v/tag/labuladong/fucking-algorithm.svg?sort=semver" alt="Last Tag" /> &lt;img src="https://img.shields.io/github/last-commit/labuladong/fucking-algorithm.svg" alt="Last commit" />
 &lt;a class="anchor" href="#labuladongfucking-algorithmhttpsgithubcomlabuladongfucking-algorithm-github-starshttpsimgshieldsiogithubstarslabuladongfucking-algorithmsvg-languagehttpsimgshieldsiogithublanguagestoplabuladongfucking-algorithmsvg-last-taghttpsimgshieldsiogithubvtaglabuladongfucking-algorithmsvgsortsemver-last-commithttpsimgshieldsiogithublast-commitlabuladongfucking-algorithmsvg">#&lt;/a>
&lt;/h3>
&lt;p>手把手撕 LeetCode 题目，扒各种算法套路的裤子，
not only how，but also why. English version supported!
&lt;a href="https://labuladong.gitbook.io/algo/">https://labuladong.gitbook.io/algo/&lt;/a>&lt;/p>
&lt;h3 id="youngyangyang04leetcode-masterhttpsgithubcomyoungyangyang04leetcode-master-github-starshttpsimgshieldsiogithubstarsyoungyangyang04leetcode-mastersvg-languagehttpsimgshieldsiogithublanguagestopyoungyangyang04leetcode-mastersvg-last-taghttpsimgshieldsiogithubvtagyoungyangyang04leetcode-mastersvgsortsemver-last-commithttpsimgshieldsiogithublast-commityoungyangyang04leetcode-mastersvg">
 &lt;a href="https://github.com/youngyangyang04/leetcode-master">youngyangyang04/leetcode-master&lt;/a> &lt;img src="https://img.shields.io/github/stars/youngyangyang04/leetcode-master.svg" alt="Github stars" /> &lt;img src="https://img.shields.io/github/languages/top/youngyangyang04/leetcode-master.svg" alt="Language" /> &lt;img src="https://img.shields.io/github/v/tag/youngyangyang04/leetcode-master.svg?sort=semver" alt="Last Tag" /> &lt;img src="https://img.shields.io/github/last-commit/youngyangyang04/leetcode-master.svg" alt="Last commit" />
 &lt;a class="anchor" href="#youngyangyang04leetcode-masterhttpsgithubcomyoungyangyang04leetcode-master-github-starshttpsimgshieldsiogithubstarsyoungyangyang04leetcode-mastersvg-languagehttpsimgshieldsiogithublanguagestopyoungyangyang04leetcode-mastersvg-last-taghttpsimgshieldsiogithubvtagyoungyangyang04leetcode-mastersvgsortsemver-last-commithttpsimgshieldsiogithublast-commityoungyangyang04leetcode-mastersvg">#&lt;/a>
&lt;/h3>
&lt;p>LeetCode 刷题攻略&lt;/p>
&lt;h3 id="donnemartininteractive-coding-challengeshttpsgithubcomdonnemartininteractive-coding-challenges-github-starshttpsimgshieldsiogithubstarsdonnemartininteractive-coding-challengessvg">
 &lt;a href="https://github.com/donnemartin/interactive-coding-challenges">donnemartin/interactive-coding-challenges&lt;/a> &lt;img src="https://img.shields.io/github/stars/donnemartin/interactive-coding-challenges.svg" alt="Github stars" />
 &lt;a class="anchor" href="#donnemartininteractive-coding-challengeshttpsgithubcomdonnemartininteractive-coding-challenges-github-starshttpsimgshieldsiogithubstarsdonnemartininteractive-coding-challengessvg">#&lt;/a>
&lt;/h3>
&lt;p>120+ interactive Python coding interview challenges (algorithms and data structures). Includes Anki flashcards.&lt;/p>
&lt;h3 id="bookkevin-waynealgs4httpsgithubcomkevin-waynealgs4-github-starshttpsimgshieldsiogithubstarskevin-waynealgs4svg">
 (book)&lt;a href="https://github.com/kevin-wayne/algs4">kevin-wayne/algs4&lt;/a> &lt;img src="https://img.shields.io/github/stars/kevin-wayne/algs4.svg" alt="Github stars" />
 &lt;a class="anchor" href="#bookkevin-waynealgs4httpsgithubcomkevin-waynealgs4-github-starshttpsimgshieldsiogithubstarskevin-waynealgs4svg">#&lt;/a>
&lt;/h3>
&lt;p>Algorithms, 4th edition textbook code and libraries&lt;/p>
&lt;hr>
&lt;h2 id="进阶">
 进阶
 &lt;a class="anchor" href="#%e8%bf%9b%e9%98%b6">#&lt;/a>
&lt;/h2></description></item><item><title>LRU Cache</title><link>https://kingye.me/study-algs/docs/advanced/common/lru/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/common/lru/</guid><description>&lt;h1 id="lru-cache">
 LRU Cache
 &lt;a class="anchor" href="#lru-cache">#&lt;/a>
&lt;/h1>
&lt;p>LRU 全称是 &lt;code>Least Recently Used&lt;/code>，即最近最久未使用的意思。&lt;/p>
&lt;p>LRU 算法的设计原则是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。
也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。&lt;/p>
&lt;h2 id="lru-k">
 LRU-K
 &lt;a class="anchor" href="#lru-k">#&lt;/a>
&lt;/h2>
&lt;p>LRU-K 中的 K 代表最近使用的次数，因此 LRU 可以认为是 LRU-1。&lt;/p>
&lt;p>LRU-K 的主要目的是为了解决 LRU 算法 “缓存污染” 的问题，
其核心思想是将 “最近使用过 1 次” 的判断标准扩展为 “最近使用过 K 次”。&lt;/p>
&lt;h2 id="redis-的-lru-实现">
 Redis 的 LRU 实现
 &lt;a class="anchor" href="#redis-%e7%9a%84-lru-%e5%ae%9e%e7%8e%b0">#&lt;/a>
&lt;/h2>
&lt;p>如果按照 HashMap 和双向链表实现，需要额外的存储存放 next 和 prev 指针，牺牲比较大的存储空间，显然是不划算的。所以 Redis 采用了一个近似的做法，就是随机取出若干个 key，然后按照访问时间排序后，淘汰掉最不经常使用的，具体分析如下：&lt;/p>
&lt;p>为了支持 LRU，Redis 2.8.19 中使用了一个全局的 LRU 时钟，&lt;code>server.lruclock&lt;/code>，定义如下，&lt;/p>
&lt;pre tabindex="0">&lt;code>#define REDIS_LRU_BITS 24
unsigned lruclock:REDIS_LRU_BITS; /* Clock for LRU eviction */
&lt;/code>&lt;/pre>&lt;p>默认的 LRU 时钟的分辨率是 1 秒，可以通过改变  &lt;code>REDIS_LRU_CLOCK_RESOLUTION&lt;/code>  宏的值来改变，Redis 会在  &lt;code>serverCron()&lt;/code>  中调用  &lt;code>updateLRUClock&lt;/code>  定期的更新 LRU 时钟，更新的频率和 hz 参数有关，默认为  &lt;code>100ms&lt;/code>  一次，如下，&lt;/p></description></item><item><title>paxos</title><link>https://kingye.me/study-algs/docs/advanced/common/paxos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/common/paxos/</guid><description>&lt;h1 id="paxos">
 paxos
 &lt;a class="anchor" href="#paxos">#&lt;/a>
&lt;/h1></description></item><item><title>raft</title><link>https://kingye.me/study-algs/docs/advanced/common/raft/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/common/raft/</guid><description>&lt;h1 id="raft">
 raft
 &lt;a class="anchor" href="#raft">#&lt;/a>
&lt;/h1></description></item><item><title>树</title><link>https://kingye.me/study-algs/docs/advanced/common/tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/common/tree/</guid><description>&lt;h1 id="树">
 树
 &lt;a class="anchor" href="#%e6%a0%91">#&lt;/a>
&lt;/h1>
&lt;h2 id="判断一棵树是否包含另一棵树的结构">
 判断一棵树是否包含另一棵树的结构
 &lt;a class="anchor" href="#%e5%88%a4%e6%96%ad%e4%b8%80%e6%a3%b5%e6%a0%91%e6%98%af%e5%90%a6%e5%8c%85%e5%90%ab%e5%8f%a6%e4%b8%80%e6%a3%b5%e6%a0%91%e7%9a%84%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h2>
&lt;p>使用树结构序列化的方法，将两棵树进行相同方式的序列化，然后利用 &lt;strong>kmp&lt;/strong> 判断子串，则可以得到&lt;/p>
&lt;p>结果，时间复杂度为 O（m+n）&lt;/p>
&lt;p>这道题的可行性是：&lt;strong>树结构的序列化和反序列化是一一对应的&lt;/strong>&lt;/p>
&lt;hr></description></item><item><title>4.2 面试题</title><link>https://kingye.me/study-algs/docs/appendix/interview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/appendix/interview/</guid><description>&lt;h1 id="算法面试题">
 算法面试题
 &lt;a class="anchor" href="#%e7%ae%97%e6%b3%95%e9%9d%a2%e8%af%95%e9%a2%98">#&lt;/a>
&lt;/h1>
&lt;h2 id="基础题">
 基础题
 &lt;a class="anchor" href="#%e5%9f%ba%e7%a1%80%e9%a2%98">#&lt;/a>
&lt;/h2>
&lt;h2 id="进阶题">
 进阶题
 &lt;a class="anchor" href="#%e8%bf%9b%e9%98%b6%e9%a2%98">#&lt;/a>
&lt;/h2></description></item><item><title>KMP</title><link>https://kingye.me/study-algs/docs/advanced/common/kmp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/common/kmp/</guid><description>&lt;h1 id="kmp">
 KMP
 &lt;a class="anchor" href="#kmp">#&lt;/a>
&lt;/h1>
&lt;p>KMP 是用来找字符串匹配的&lt;/p>
&lt;p>KMP 的时间复杂度是 O (m + n)&lt;/p>
&lt;h2 id="参考">
 参考
 &lt;a class="anchor" href="#%e5%8f%82%e8%80%83">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.zhihu.com/question/21923021">如何更好地理解和掌握 KMP 算法？&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/83334559">KMP 算法详解&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.inf.hs-flensburg.de/lang/algorithmen/pattern/kmpen.htm">Knuth-Morris-Pratt algorithm&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/112861530">KMP：花 48 小时看懂了 KMP，想让你在 48 分钟内看懂&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>布隆过滤器</title><link>https://kingye.me/study-algs/docs/advanced/common/bloom/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/common/bloom/</guid><description>&lt;h1 id="布隆过滤器httpswwwwikiwandcomzh-cne5b883e99a86e8bf87e6bba4e599a8">
 &lt;a href="https://www.wikiwand.com/zh-cn/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8">布隆过滤器&lt;/a>
 &lt;a class="anchor" href="#%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8httpswwwwikiwandcomzh-cne5b883e99a86e8bf87e6bba4e599a8">#&lt;/a>
&lt;/h1>
&lt;p>布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。
它实际上是一个&lt;strong>很长的二进制向量&lt;/strong>和&lt;strong>一系列随机映射函数&lt;/strong>。
布隆过滤器可以用于检索一个元素是否在一个集合中。
它的优点是&lt;strong>空间效率&lt;/strong>和&lt;strong>查询时间&lt;/strong>都比一般的算法要好的多，
缺点是有一定的&lt;strong>误识别率&lt;/strong>和&lt;strong>删除困难&lt;/strong>。&lt;/p>
&lt;p>解决：
网页 URL 去重、垃圾邮件识别、大集合中重复元素的判断和缓存穿透等问题&lt;/p>
&lt;p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你
某样东西&lt;strong>一定不存在&lt;/strong>或者&lt;strong>可能存在&lt;/strong>。&lt;/p>
&lt;p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。&lt;/p>
&lt;h2 id="hashmap-的问题">
 HashMap 的问题
 &lt;a class="anchor" href="#hashmap-%e7%9a%84%e9%97%ae%e9%a2%98">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能&lt;strong>一次性读进内存&lt;/strong>构建 HashMap 的时候，也会存在问题。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="布隆过滤器的原理">
 布隆过滤器的原理
 &lt;a class="anchor" href="#%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8%e7%9a%84%e5%8e%9f%e7%90%86">#&lt;/a>
&lt;/h2>
&lt;p>当一个元素被加入集合时，通过 K 个&lt;a href="https://www.wikiwand.com/zh-cn/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0">散列函数&lt;/a>将这个元素映射成一个位&lt;a href="https://www.wikiwand.com/zh-cn/%E6%95%B0%E7%BB%84" title="数组">数组&lt;/a>中的 K 个点，把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在。&lt;/p>
&lt;hr>
&lt;h2 id="应用">
 应用
 &lt;a class="anchor" href="#%e5%ba%94%e7%94%a8">#&lt;/a>
&lt;/h2>
&lt;p>在大数据场景应用比较多，比如 Hbase 中使用它去判断数据是否在磁盘上。&lt;/p>
&lt;p>还有在爬虫场景判断 url 是否已经被爬取过。&lt;/p>
&lt;h3 id="在缓存之前在加一层-bloomfilter">
 在缓存之前在加一层 BloomFilter
 &lt;a class="anchor" href="#%e5%9c%a8%e7%bc%93%e5%ad%98%e4%b9%8b%e5%89%8d%e5%9c%a8%e5%8a%a0%e4%b8%80%e5%b1%82-bloomfilter">#&lt;/a>
&lt;/h3></description></item><item><title>递归</title><link>https://kingye.me/study-algs/docs/basic/thought/recursive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/basic/thought/recursive/</guid><description>&lt;h1 id="递归">
 递归
 &lt;a class="anchor" href="#%e9%80%92%e5%bd%92">#&lt;/a>
&lt;/h1>
&lt;h2 id="参考">
 参考
 &lt;a class="anchor" href="#%e5%8f%82%e8%80%83">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://lyl0724.github.io/2020/01/25/1/">三道题套路解决递归问题&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>4.3 关注项目</title><link>https://kingye.me/study-algs/docs/appendix/attention/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/appendix/attention/</guid><description>&lt;h1 id="关注项目">
 关注项目
 &lt;a class="anchor" href="#%e5%85%b3%e6%b3%a8%e9%a1%b9%e7%9b%ae">#&lt;/a>
&lt;/h1></description></item><item><title>54. 螺旋矩阵</title><link>https://kingye.me/study-algs/docs/advanced/leetcode/0/54/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/leetcode/0/54/</guid><description>&lt;h1 id="螺旋矩阵">
 螺旋矩阵
 &lt;a class="anchor" href="#%e8%9e%ba%e6%97%8b%e7%9f%a9%e9%98%b5">#&lt;/a>
&lt;/h1>
&lt;h2 id="题目httpsleetcode-cncomproblemsspiral-matrix">
 &lt;a href="https://leetcode-cn.com/problems/spiral-matrix">题目&lt;/a>
 &lt;a class="anchor" href="#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemsspiral-matrix">#&lt;/a>
&lt;/h2>




&lt;div class="book-tabs">&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-0" checked="checked" />
 &lt;label for="tabs-leetcode-problem-0">中文&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>给定一个包含  m x n  个元素的矩阵（m 行，n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。&lt;/p>
&lt;p>示例  1:&lt;/p>
&lt;pre tabindex="0">&lt;code>输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
输出: [1,2,3,6,9,8,7,4,5]
&lt;/code>&lt;/pre>&lt;p>示例  2:&lt;/p>
&lt;pre tabindex="0">&lt;code>输入:
[
 [1, 2, 3, 4],
 [5, 6, 7, 8],
 [9,10,11,12]
]
输出: [1,2,3,4,8,12,11,10,9,5,6,7]
&lt;/code>&lt;/pre>&lt;/div>&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-1" />
 &lt;label for="tabs-leetcode-problem-1">English&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.&lt;/p></description></item><item><title>71. 简化路径</title><link>https://kingye.me/study-algs/docs/advanced/leetcode/0/71/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/leetcode/0/71/</guid><description>&lt;h1 id="模板">
 模板
 &lt;a class="anchor" href="#%e6%a8%a1%e6%9d%bf">#&lt;/a>
&lt;/h1>
&lt;h2 id="题目httpsleetcode-cncomproblemssimplify-path">
 &lt;a href="https://leetcode-cn.com/problems/simplify-path/">题目&lt;/a>
 &lt;a class="anchor" href="#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemssimplify-path">#&lt;/a>
&lt;/h2>




&lt;div class="book-tabs">&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-0" checked="checked" />
 &lt;label for="tabs-leetcode-problem-0">中文&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。&lt;/p>
&lt;p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..）  表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix 中的绝对路径 vs 相对路径&lt;/p>
&lt;p>请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。&lt;/p>
&lt;p>示例 1：&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：&amp;#34;/home/&amp;#34;
输出：&amp;#34;/home&amp;#34;
解释：注意，最后一个目录名后面没有斜杠。
&lt;/code>&lt;/pre>&lt;p>示例 2：&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：&amp;#34;/../&amp;#34;
输出：&amp;#34;/&amp;#34;
解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。
&lt;/code>&lt;/pre>&lt;p>示例 3：&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：&amp;#34;/home//foo/&amp;#34;
输出：&amp;#34;/home/foo&amp;#34;
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
&lt;/code>&lt;/pre>&lt;p>示例 4：&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：&amp;#34;/a/./b/../../c/&amp;#34;
输出：&amp;#34;/c&amp;#34;
&lt;/code>&lt;/pre>&lt;p>示例 5：&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：&amp;#34;/a/../../b/../c//.//&amp;#34;
输出：&amp;#34;/c&amp;#34;
&lt;/code>&lt;/pre>&lt;p>示例 6：&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：&amp;#34;/a//b////c/d//././/..&amp;#34;
输出：&amp;#34;/a/b/c&amp;#34;
&lt;/code>&lt;/pre>&lt;/div>&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-1" />
 &lt;label for="tabs-leetcode-problem-1">English&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path.&lt;/p>
&lt;p>In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level.&lt;/p></description></item><item><title>110. 平衡二叉树</title><link>https://kingye.me/study-algs/docs/advanced/leetcode/1/110/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/leetcode/1/110/</guid><description>&lt;h1 id="平衡二叉树">
 平衡二叉树
 &lt;a class="anchor" href="#%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%a0%91">#&lt;/a>
&lt;/h1>
&lt;h2 id="题目httpsleetcode-cncomproblemsbalanced-binary-tree">
 &lt;a href="https://leetcode-cn.com/problems/balanced-binary-tree/">题目&lt;/a>
 &lt;a class="anchor" href="#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemsbalanced-binary-tree">#&lt;/a>
&lt;/h2>




&lt;div class="book-tabs">&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-0" checked="checked" />
 &lt;label for="tabs-leetcode-problem-0">中文&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;/p>
&lt;p>本题中，一棵高度平衡二叉树定义为：&lt;/p>
&lt;p>一个二叉树每个节点   的左右两个子树的高度差的绝对值不超过 1。&lt;/p>
&lt;p>示例 1:&lt;/p>
&lt;pre tabindex="0">&lt;code>给定二叉树 [3,9,20,null,null,15,7]

 3
 / \
 9 20
 / \
 15 7
&lt;/code>&lt;/pre>&lt;p>返回 true 。&lt;/p>
&lt;p>示例 2:&lt;/p>
&lt;pre tabindex="0">&lt;code>给定二叉树 [1,2,2,3,3,null,null,4,4]

 1
 / \
 2 2
 / \
 3 3
 / \
 4 4
返回 false 。
&lt;/code>&lt;/pre>&lt;/div>&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-1" />
 &lt;label for="tabs-leetcode-problem-1">English&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>Given a binary tree, determine if it is height-balanced.&lt;/p>
&lt;p>For this problem, a height-balanced binary tree is defined as:&lt;/p>
&lt;p>a binary tree in which the left and right subtrees of every node differ in height by no more than 1.&lt;/p></description></item><item><title>146. LRU 缓存机制</title><link>https://kingye.me/study-algs/docs/advanced/leetcode/1/146/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/leetcode/1/146/</guid><description>&lt;h1 id="lru-缓存机制">
 LRU 缓存机制
 &lt;a class="anchor" href="#lru-%e7%bc%93%e5%ad%98%e6%9c%ba%e5%88%b6">#&lt;/a>
&lt;/h1>
&lt;h2 id="题目httpsleetcode-cncomproblemslru-cache">
 &lt;a href="https://leetcode-cn.com/problems/lru-cache">题目&lt;/a>
 &lt;a class="anchor" href="#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemslru-cache">#&lt;/a>
&lt;/h2>




&lt;div class="book-tabs">&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-0" checked="checked" />
 &lt;label for="tabs-leetcode-problem-0">中文&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>运用你所掌握的数据结构，设计和实现一个 &lt;a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用)&lt;/a> 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。&lt;/p>
&lt;p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
写入数据 put(key, value) - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥 / 数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。&lt;/p>
&lt;p>进阶:&lt;/p>
&lt;p>你是否可以在  &lt;code>O(1)&lt;/code> 时间复杂度内完成这两种操作？&lt;/p>
&lt;p>示例:&lt;/p>
&lt;pre tabindex="0">&lt;code>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1); // 返回 1
cache.put(3, 3); // 该操作会使得密钥 2 作废
cache.get(2); // 返回 -1 (未找到)
cache.put(4, 4); // 该操作会使得密钥 1 作废
cache.get(1); // 返回 -1 (未找到)
cache.get(3); // 返回 3
cache.get(4); // 返回 4
&lt;/code>&lt;/pre>&lt;/div>&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-1" />
 &lt;label for="tabs-leetcode-problem-1">English&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>Design and implement a data structure for &lt;a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU">Least Recently Used (LRU)&lt;/a> cache. It should support the following operations: get and put.&lt;/p></description></item><item><title>206. 反转链表</title><link>https://kingye.me/study-algs/docs/advanced/leetcode/2/206/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/leetcode/2/206/</guid><description>&lt;h1 id="反转链表">
 反转链表
 &lt;a class="anchor" href="#%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8">#&lt;/a>
&lt;/h1>
&lt;h2 id="题目httpsleetcode-cncomproblemsreverse-linked-list">
 &lt;a href="https://leetcode-cn.com/problems/reverse-linked-list/">题目&lt;/a>
 &lt;a class="anchor" href="#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemsreverse-linked-list">#&lt;/a>
&lt;/h2>




&lt;div class="book-tabs">&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-0" checked="checked" />
 &lt;label for="tabs-leetcode-problem-0">中文&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。&lt;/p>
&lt;p>示例 1：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>输入：head &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>1,2,3,4,5&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>输出：&lt;span style="color:#f92672">[&lt;/span>5,4,3,2,1&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>示例 2：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>输入：head &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>1,2&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>输出：&lt;span style="color:#f92672">[&lt;/span>2,1&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>示例 3：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>输入：head &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>输出：&lt;span style="color:#f92672">[]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>提示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>链表中节点的数目范围是 &lt;span style="color:#f92672">[&lt;/span>0, 5000&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-5000 &amp;lt;&lt;span style="color:#f92672">=&lt;/span> Node.val &amp;lt;&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5000&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？&lt;/p>
&lt;/div>&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-1" />
 &lt;label for="tabs-leetcode-problem-1">English&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>Given the head of a singly linked list, reverse the list, and return the reversed list.&lt;/p>
&lt;p>Example 1:&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
&lt;/code>&lt;/pre>&lt;p>Example 2:&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: head = [1,2]
Output: [2,1]
&lt;/code>&lt;/pre>&lt;p>Example 3:&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: head = []
Output: []
&lt;/code>&lt;/pre>&lt;p>Constraints:&lt;/p>
&lt;pre tabindex="0">&lt;code>The number of nodes in the list is the range [0, 5000].
-5000 &amp;lt;= Node.val &amp;lt;= 5000
&lt;/code>&lt;/pre>&lt;p>Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?&lt;/p></description></item><item><title>671. 二叉树中第二小的节点</title><link>https://kingye.me/study-algs/docs/advanced/leetcode/6/671/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kingye.me/study-algs/docs/advanced/leetcode/6/671/</guid><description>&lt;h1 id="二叉树中第二小的节点">
 二叉树中第二小的节点
 &lt;a class="anchor" href="#%e4%ba%8c%e5%8f%89%e6%a0%91%e4%b8%ad%e7%ac%ac%e4%ba%8c%e5%b0%8f%e7%9a%84%e8%8a%82%e7%82%b9">#&lt;/a>
&lt;/h1>
&lt;h2 id="题目httpsleetcode-cncomproblemssecond-minimum-node-in-a-binary-tree">
 &lt;a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/">题目&lt;/a>
 &lt;a class="anchor" href="#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemssecond-minimum-node-in-a-binary-tree">#&lt;/a>
&lt;/h2>




&lt;div class="book-tabs">&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-0" checked="checked" />
 &lt;label for="tabs-leetcode-problem-0">中文&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为  2  或  0。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。&lt;/p>
&lt;p>给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。&lt;/p>
&lt;p>示例 1:&lt;/p>
&lt;pre tabindex="0">&lt;code>输入:
 2
 / \
 2 5
 / \
 5 7

输出: 5
说明: 最小的值是 2 ，第二小的值是 5 。
&lt;/code>&lt;/pre>&lt;p>示例 2:&lt;/p>
&lt;pre tabindex="0">&lt;code>输入:
 2
 / \
 2 2

输出: -1
说明: 最小的值是 2, 但是不存在第二小的值。
&lt;/code>&lt;/pre>&lt;/div>&lt;input type="radio" class="toggle" name="tabs-leetcode-problem" id="tabs-leetcode-problem-1" />
 &lt;label for="tabs-leetcode-problem-1">English&lt;/label>
 &lt;div class="book-tabs-content markdown-inner">&lt;p>Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node&amp;rsquo;s value is the smaller value among its two sub-nodes. More formally, the property root.val = min(root.left.val, root.right.val) always holds.&lt;/p></description></item></channel></rss>