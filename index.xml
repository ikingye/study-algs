<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>首页 on 算法学习笔记</title>
    <link>https://kingye.me/study-algs/</link>
    <description>Recent content in 首页 on 算法学习笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="https://kingye.me/study-algs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1. 两数之和</title>
      <link>https://kingye.me/study-algs/docs/advanced/leetcode/0/1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/advanced/leetcode/0/1/</guid>
      <description>&lt;h1 id=&#34;两数之和&#34;&gt;&#xA;  两数之和&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%a4%e6%95%b0%e4%b9%8b%e5%92%8c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目httpsleetcode-cncomproblemstwo-sum&#34;&gt;&#xA;  &lt;a href=&#34;https://leetcode-cn.com/problems/two-sum&#34;&gt;题目&lt;/a&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemstwo-sum&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-0&#34; checked=&#34;checked&#34; /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-0&#34;&gt;中文&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;给定一个整数数组 nums  和一个目标值 target，请你在该数组中找出和为目标值的那&lt;strong&gt;两个&lt;/strong&gt;整数，并返回他们的数组下标。&lt;/p&gt;&#xA;&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;&#xA;&lt;p&gt;示例:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;给定 nums = [2, 7, 11, 15], target = 9&#xA;&#xA;因为 nums[0] + nums[1] = 2 + 7 = 9&#xA;所以返回 [0, 1]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-1&#34;  /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-1&#34;&gt;English&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.&lt;/p&gt;&#xA;&lt;p&gt;You may assume that each input would have exactly one solution, and you may not use the same element twice.&lt;/p&gt;</description>
    </item>
    <item>
      <title>2. 两数相加</title>
      <link>https://kingye.me/study-algs/docs/advanced/leetcode/0/2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/advanced/leetcode/0/2/</guid>
      <description>&lt;h1 id=&#34;两数相加&#34;&gt;&#xA;  两数相加&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%a4%e6%95%b0%e7%9b%b8%e5%8a%a0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目httpsleetcode-cncomproblemsadd-two-numbers&#34;&gt;&#xA;  &lt;a href=&#34;https://leetcode-cn.com/problems/add-two-numbers/&#34;&gt;题目&lt;/a&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemsadd-two-numbers&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-0&#34; checked=&#34;checked&#34; /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-0&#34;&gt;中文&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;给出两个   非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照   逆序   的方式存储的，并且它们的每个节点只能存储   一位   数字。&lt;/p&gt;&#xA;&lt;p&gt;如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&lt;/p&gt;&#xA;&lt;p&gt;您可以假设除了数字 0 之外，这两个数都不会以 0  开头。&lt;/p&gt;&#xA;&lt;p&gt;示例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入：(2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)&#xA;输出：7 -&amp;gt; 0 -&amp;gt; 8&#xA;原因：342 + 465 = 807&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-1&#34;  /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-1&#34;&gt;English&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.&lt;/p&gt;</description>
    </item>
    <item>
      <title>3. 无重复字符的最长子串</title>
      <link>https://kingye.me/study-algs/docs/advanced/leetcode/0/3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/advanced/leetcode/0/3/</guid>
      <description>&lt;h1 id=&#34;无重复字符的最长子串&#34;&gt;&#xA;  无重复字符的最长子串&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%a0%e9%87%8d%e5%a4%8d%e5%ad%97%e7%ac%a6%e7%9a%84%e6%9c%80%e9%95%bf%e5%ad%90%e4%b8%b2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目httpsleetcode-cncomproblemslongest-substring-without-repeating-characters&#34;&gt;&#xA;  &lt;a href=&#34;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&#34;&gt;题目&lt;/a&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemslongest-substring-without-repeating-characters&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-0&#34; checked=&#34;checked&#34; /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-0&#34;&gt;中文&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的   最长子串   的长度。&lt;/p&gt;&#xA;&lt;p&gt;示例  1:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入: &amp;#34;abcabcbb&amp;#34;&#xA;输出: 3&#xA;解释: 因为无重复字符的最长子串是 &amp;#34;abc&amp;#34;，所以其长度为 3。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例 2:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入: &amp;#34;bbbbb&amp;#34;&#xA;输出: 1&#xA;解释: 因为无重复字符的最长子串是 &amp;#34;b&amp;#34;，所以其长度为 1。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例 3:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入: &amp;#34;pwwkew&amp;#34;&#xA;输出: 3&#xA;解释: 因为无重复字符的最长子串是 &amp;#34;wke&amp;#34;，所以其长度为 3。&#xA;     请注意，你的答案必须是 子串 的长度，&amp;#34;pwke&amp;#34; 是一个子序列，不是子串。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-1&#34;  /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-1&#34;&gt;English&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;Given a string, find the length of the longest substring without repeating characters.&lt;/p&gt;&#xA;&lt;p&gt;Example 1:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: &amp;#34;abcabcbb&amp;#34;&#xA;Output: 3&#xA;Explanation: The answer is &amp;#34;abc&amp;#34;, with the length of 3.&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Example 2:&lt;/p&gt;</description>
    </item>
    <item>
      <title>4. 寻找两个有序数组的中位数</title>
      <link>https://kingye.me/study-algs/docs/advanced/leetcode/0/4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/advanced/leetcode/0/4/</guid>
      <description>&lt;h1 id=&#34;寻找两个有序数组的中位数&#34;&gt;&#xA;  寻找两个有序数组的中位数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%bb%e6%89%be%e4%b8%a4%e4%b8%aa%e6%9c%89%e5%ba%8f%e6%95%b0%e7%bb%84%e7%9a%84%e4%b8%ad%e4%bd%8d%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目httpsleetcode-cncomproblemsmedian-of-two-sorted-arrays&#34;&gt;&#xA;  &lt;a href=&#34;https://leetcode-cn.com/problems/median-of-two-sorted-arrays/&#34;&gt;题目&lt;/a&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemsmedian-of-two-sorted-arrays&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-0&#34; checked=&#34;checked&#34; /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-0&#34;&gt;中文&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;给定两个大小为 m 和 n 的有序数组  nums1 和  nums2。&lt;/p&gt;&#xA;&lt;p&gt;请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为  O (log (m + n))。&lt;/p&gt;&#xA;&lt;p&gt;你可以假设  nums1  和  nums2  不会同时为空。&lt;/p&gt;&#xA;&lt;p&gt;示例 1:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;nums1 = [1, 3]&#xA;nums2 = [2]&#xA;&#xA;则中位数是 2.0&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例 2:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;nums1 = [1, 2]&#xA;nums2 = [3, 4]&#xA;&#xA;则中位数是 (2 + 3)/2 = 2.5&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-1&#34;  /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-1&#34;&gt;English&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;There are two sorted arrays nums1 and nums2 of size m and n respectively.&lt;/p&gt;&#xA;&lt;p&gt;Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).&lt;/p&gt;</description>
    </item>
    <item>
      <title>7. 整数反转</title>
      <link>https://kingye.me/study-algs/docs/advanced/leetcode/0/7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/advanced/leetcode/0/7/</guid>
      <description>&lt;h1 id=&#34;整数反转&#34;&gt;&#xA;  整数反转&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b4%e6%95%b0%e5%8f%8d%e8%bd%ac&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目httpsleetcode-cncomproblemsreverse-integer&#34;&gt;&#xA;  &lt;a href=&#34;https://leetcode-cn.com/problems/reverse-integer/&#34;&gt;题目&lt;/a&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemsreverse-integer&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem-1&#34; id=&#34;tabs-leetcode-problem-1-0&#34; checked=&#34;checked&#34; /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-1-0&#34;&gt;中文&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;&#xA;&lt;p&gt;示例  1:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入: 123&#xA;输出: 321&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例 2:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入: -123&#xA;输出: -321&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例 3:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入: 120&#xA;输出: 21&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意:&lt;/p&gt;&#xA;&lt;p&gt;假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为&lt;/p&gt;&#xA;&lt;link rel=&#34;stylesheet&#34; href=&#34;https://kingye.me/study-algs/study-algs/katex/katex.min.css&#34; /&gt;&#xA;&lt;script defer src=&#34;https://kingye.me/study-algs/study-algs/katex/katex.min.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script defer src=&#34;https://kingye.me/study-algs/study-algs/katex/auto-render.min.js&#34; onload=&#34;renderMathInElement(document.body, {&#xA;  delimiters: [&#xA;      {left: &#39;$$&#39;, right: &#39;$$&#39;, display: true},&#xA;      {left: &#39;\\[&#39;, right: &#39;\\]&#39;, display: true},&#xA;      {left: &#39;$&#39;, right: &#39;$&#39;, display: false},&#xA;      {left: &#39;\\(&#39;, right: &#39;\\)&#39;, display: false}&#xA;  ]&#xA;});&#34;&gt;&lt;/script&gt;&lt;span&gt;&#xA;  \([-2^31, 2^31-1]。\)&#xA;&lt;/span&gt;&#xA;&lt;p&gt;请根据这个假设，如果反转后整数溢出那么就返回 0。&lt;/p&gt;&#xA;&lt;/div&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem-1&#34; id=&#34;tabs-leetcode-problem-1-1&#34;  /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-1-1&#34;&gt;English&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;Given a 32-bit signed integer, reverse digits of an integer.&lt;/p&gt;</description>
    </item>
    <item>
      <title>9. 回文数</title>
      <link>https://kingye.me/study-algs/docs/advanced/leetcode/0/9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/advanced/leetcode/0/9/</guid>
      <description>&lt;h1 id=&#34;回文数&#34;&gt;&#xA;  回文数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9b%9e%e6%96%87%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目httpsleetcode-cncomproblemspalindrome-number&#34;&gt;&#xA;  &lt;a href=&#34;https://leetcode-cn.com/problems/palindrome-number/&#34;&gt;题目&lt;/a&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemspalindrome-number&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-0&#34; checked=&#34;checked&#34; /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-0&#34;&gt;中文&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;&#xA;&lt;p&gt;示例 1:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入: 121&#xA;输出: true&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例  2:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入: -121&#xA;输出: false&#xA;解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例 3:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入: 10&#xA;输出: false&#xA;解释: 从右向左读, 为 01 。因此它不是一个回文数。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;进阶:&lt;/p&gt;&#xA;&lt;p&gt;你能不将整数转为字符串来解决这个问题吗？&lt;/p&gt;&#xA;&lt;/div&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-1&#34;  /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-1&#34;&gt;English&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.&lt;/p&gt;&#xA;&lt;p&gt;Example 1:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: 121&#xA;Output: true&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Example 2:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: -121&#xA;Output: false&#xA;Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Example 3:&lt;/p&gt;</description>
    </item>
    <item>
      <title>1.3.1 排序算法</title>
      <link>https://kingye.me/study-algs/docs/advanced/common/sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/advanced/common/sort/</guid>
      <description>&lt;h1 id=&#34;排序算法&#34;&gt;&#xA;  排序算法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ikingye/imagehost/picgo/20200424114357.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>10. 正则表达式匹配</title>
      <link>https://kingye.me/study-algs/docs/advanced/leetcode/0/10/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/advanced/leetcode/0/10/</guid>
      <description>&lt;h1 id=&#34;正则表达式匹配&#34;&gt;&#xA;  正则表达式匹配&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%8c%b9%e9%85%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目httpsleetcode-cncomproblemstwo-sum&#34;&gt;&#xA;  &lt;a href=&#34;https://leetcode-cn.com/problems/two-sum&#34;&gt;题目&lt;/a&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemstwo-sum&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-0&#34; checked=&#34;checked&#34; /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-0&#34;&gt;中文&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;给你一个字符串  s  和一个字符规律  p，请你来实现一个支持 &amp;lsquo;.&amp;rsquo;  和  &amp;lsquo;*&amp;rsquo;  的正则表达式匹配。&lt;/p&gt;&#xA;&lt;p&gt;&amp;lsquo;.&amp;rsquo; 匹配任意单个字符&#xA;&amp;lsquo;*&amp;rsquo; 匹配零个或多个前面的那一个元素&#xA;所谓匹配，是要涵盖   整个   字符串  s 的，而不是部分字符串。&lt;/p&gt;&#xA;&lt;p&gt;说明:&lt;/p&gt;&#xA;&lt;p&gt;s  可能为空，且只包含从  a-z  的小写字母。&#xA;p  可能为空，且只包含从  a-z  的小写字母，以及字符  .  和  *。&#xA;示例 1:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入:&#xA;s = &amp;#34;aa&amp;#34;&#xA;p = &amp;#34;a&amp;#34;&#xA;输出: false&#xA;解释: &amp;#34;a&amp;#34; 无法匹配 &amp;#34;aa&amp;#34; 整个字符串。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例 2:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入:&#xA;s = &amp;#34;aa&amp;#34;&#xA;p = &amp;#34;a*&amp;#34;&#xA;输出: true&#xA;解释: 因为 &amp;#39;*&amp;#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &amp;#39;a&amp;#39;。因此，字符串 &amp;#34;aa&amp;#34; 可被视为 &amp;#39;a&amp;#39; 重复了一次。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例  3:&lt;/p&gt;</description>
    </item>
    <item>
      <title>4.1 教程</title>
      <link>https://kingye.me/study-algs/docs/appendix/tutorial/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/appendix/tutorial/</guid>
      <description>&lt;h1 id=&#34;算法教程&#34;&gt;&#xA;  算法教程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%97%e6%b3%95%e6%95%99%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;labuladongfucking-algorithmhttpsgithubcomlabuladongfucking-algorithm-github-starshttpsimgshieldsiogithubstarslabuladongfucking-algorithmsvg-languagehttpsimgshieldsiogithublanguagestoplabuladongfucking-algorithmsvg-last-taghttpsimgshieldsiogithubvtaglabuladongfucking-algorithmsvgsortsemver-last-commithttpsimgshieldsiogithublast-commitlabuladongfucking-algorithmsvg&#34;&gt;&#xA;  &lt;a href=&#34;https://github.com/labuladong/fucking-algorithm&#34;&gt;labuladong/fucking-algorithm&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/stars/labuladong/fucking-algorithm.svg&#34; alt=&#34;Github stars&#34; /&gt; &lt;img src=&#34;https://img.shields.io/github/languages/top/labuladong/fucking-algorithm.svg&#34; alt=&#34;Language&#34; /&gt; &lt;img src=&#34;https://img.shields.io/github/v/tag/labuladong/fucking-algorithm.svg?sort=semver&#34; alt=&#34;Last Tag&#34; /&gt; &lt;img src=&#34;https://img.shields.io/github/last-commit/labuladong/fucking-algorithm.svg&#34; alt=&#34;Last commit&#34; /&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#labuladongfucking-algorithmhttpsgithubcomlabuladongfucking-algorithm-github-starshttpsimgshieldsiogithubstarslabuladongfucking-algorithmsvg-languagehttpsimgshieldsiogithublanguagestoplabuladongfucking-algorithmsvg-last-taghttpsimgshieldsiogithubvtaglabuladongfucking-algorithmsvgsortsemver-last-commithttpsimgshieldsiogithublast-commitlabuladongfucking-algorithmsvg&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;手把手撕 LeetCode 题目，扒各种算法套路的裤子，&#xA;not only how，but also why. English version supported!&#xA;&lt;a href=&#34;https://labuladong.gitbook.io/algo/&#34;&gt;https://labuladong.gitbook.io/algo/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;youngyangyang04leetcode-masterhttpsgithubcomyoungyangyang04leetcode-master-github-starshttpsimgshieldsiogithubstarsyoungyangyang04leetcode-mastersvg-languagehttpsimgshieldsiogithublanguagestopyoungyangyang04leetcode-mastersvg-last-taghttpsimgshieldsiogithubvtagyoungyangyang04leetcode-mastersvgsortsemver-last-commithttpsimgshieldsiogithublast-commityoungyangyang04leetcode-mastersvg&#34;&gt;&#xA;  &lt;a href=&#34;https://github.com/youngyangyang04/leetcode-master&#34;&gt;youngyangyang04/leetcode-master&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/stars/youngyangyang04/leetcode-master.svg&#34; alt=&#34;Github stars&#34; /&gt; &lt;img src=&#34;https://img.shields.io/github/languages/top/youngyangyang04/leetcode-master.svg&#34; alt=&#34;Language&#34; /&gt; &lt;img src=&#34;https://img.shields.io/github/v/tag/youngyangyang04/leetcode-master.svg?sort=semver&#34; alt=&#34;Last Tag&#34; /&gt; &lt;img src=&#34;https://img.shields.io/github/last-commit/youngyangyang04/leetcode-master.svg&#34; alt=&#34;Last commit&#34; /&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#youngyangyang04leetcode-masterhttpsgithubcomyoungyangyang04leetcode-master-github-starshttpsimgshieldsiogithubstarsyoungyangyang04leetcode-mastersvg-languagehttpsimgshieldsiogithublanguagestopyoungyangyang04leetcode-mastersvg-last-taghttpsimgshieldsiogithubvtagyoungyangyang04leetcode-mastersvgsortsemver-last-commithttpsimgshieldsiogithublast-commityoungyangyang04leetcode-mastersvg&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;LeetCode 刷题攻略&lt;/p&gt;&#xA;&lt;h3 id=&#34;donnemartininteractive-coding-challengeshttpsgithubcomdonnemartininteractive-coding-challenges-github-starshttpsimgshieldsiogithubstarsdonnemartininteractive-coding-challengessvg&#34;&gt;&#xA;  &lt;a href=&#34;https://github.com/donnemartin/interactive-coding-challenges&#34;&gt;donnemartin/interactive-coding-challenges&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/stars/donnemartin/interactive-coding-challenges.svg&#34; alt=&#34;Github stars&#34; /&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#donnemartininteractive-coding-challengeshttpsgithubcomdonnemartininteractive-coding-challenges-github-starshttpsimgshieldsiogithubstarsdonnemartininteractive-coding-challengessvg&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;120+ interactive Python coding interview challenges (algorithms and data structures). Includes Anki flashcards.&lt;/p&gt;&#xA;&lt;h3 id=&#34;bookkevin-waynealgs4httpsgithubcomkevin-waynealgs4-github-starshttpsimgshieldsiogithubstarskevin-waynealgs4svg&#34;&gt;&#xA;  (book)&lt;a href=&#34;https://github.com/kevin-wayne/algs4&#34;&gt;kevin-wayne/algs4&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/stars/kevin-wayne/algs4.svg&#34; alt=&#34;Github stars&#34; /&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#bookkevin-waynealgs4httpsgithubcomkevin-waynealgs4-github-starshttpsimgshieldsiogithubstarskevin-waynealgs4svg&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;Algorithms, 4th edition textbook code and libraries&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;进阶&#34;&gt;&#xA;  进阶&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9b%e9%98%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>LRU Cache</title>
      <link>https://kingye.me/study-algs/docs/advanced/common/lru/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/advanced/common/lru/</guid>
      <description>&lt;h1 id=&#34;lru-cache&#34;&gt;&#xA;  LRU Cache&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#lru-cache&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;LRU 全称是 &lt;code&gt;Least Recently Used&lt;/code&gt;，即最近最久未使用的意思。&lt;/p&gt;&#xA;&lt;p&gt;LRU 算法的设计原则是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。&#xA;也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。&lt;/p&gt;&#xA;&lt;h2 id=&#34;lru-k&#34;&gt;&#xA;  LRU-K&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#lru-k&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;LRU-K 中的 K 代表最近使用的次数，因此 LRU 可以认为是 LRU-1。&lt;/p&gt;&#xA;&lt;p&gt;LRU-K 的主要目的是为了解决 LRU 算法 “缓存污染” 的问题，&#xA;其核心思想是将 “最近使用过 1 次” 的判断标准扩展为 “最近使用过 K 次”。&lt;/p&gt;&#xA;&lt;h2 id=&#34;redis-的-lru-实现&#34;&gt;&#xA;  Redis 的 LRU 实现&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redis-%e7%9a%84-lru-%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;如果按照 HashMap 和双向链表实现，需要额外的存储存放 next 和 prev 指针，牺牲比较大的存储空间，显然是不划算的。所以 Redis 采用了一个近似的做法，就是随机取出若干个 key，然后按照访问时间排序后，淘汰掉最不经常使用的，具体分析如下：&lt;/p&gt;&#xA;&lt;p&gt;为了支持 LRU，Redis 2.8.19 中使用了一个全局的 LRU 时钟，&lt;code&gt;server.lruclock&lt;/code&gt;，定义如下，&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#define REDIS_LRU_BITS 24&#xA;unsigned lruclock:REDIS_LRU_BITS; /* Clock for LRU eviction */&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;默认的 LRU 时钟的分辨率是 1 秒，可以通过改变  &lt;code&gt;REDIS_LRU_CLOCK_RESOLUTION&lt;/code&gt;  宏的值来改变，Redis 会在  &lt;code&gt;serverCron()&lt;/code&gt;  中调用  &lt;code&gt;updateLRUClock&lt;/code&gt;  定期的更新 LRU 时钟，更新的频率和 hz 参数有关，默认为  &lt;code&gt;100ms&lt;/code&gt;  一次，如下，&lt;/p&gt;</description>
    </item>
    <item>
      <title>paxos</title>
      <link>https://kingye.me/study-algs/docs/advanced/common/paxos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/advanced/common/paxos/</guid>
      <description>&lt;h1 id=&#34;paxos&#34;&gt;&#xA;  paxos&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#paxos&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;</description>
    </item>
    <item>
      <title>raft</title>
      <link>https://kingye.me/study-algs/docs/advanced/common/raft/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/advanced/common/raft/</guid>
      <description>&lt;h1 id=&#34;raft&#34;&gt;&#xA;  raft&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#raft&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;</description>
    </item>
    <item>
      <title>树</title>
      <link>https://kingye.me/study-algs/docs/advanced/common/tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/advanced/common/tree/</guid>
      <description>&lt;h1 id=&#34;树&#34;&gt;&#xA;  树&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;判断一棵树是否包含另一棵树的结构&#34;&gt;&#xA;  判断一棵树是否包含另一棵树的结构&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%a4%e6%96%ad%e4%b8%80%e6%a3%b5%e6%a0%91%e6%98%af%e5%90%a6%e5%8c%85%e5%90%ab%e5%8f%a6%e4%b8%80%e6%a3%b5%e6%a0%91%e7%9a%84%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;使用树结构序列化的方法，将两棵树进行相同方式的序列化，然后利用 &lt;strong&gt;kmp&lt;/strong&gt; 判断子串，则可以得到&lt;/p&gt;&#xA;&lt;p&gt;结果，时间复杂度为 O（m+n）&lt;/p&gt;&#xA;&lt;p&gt;这道题的可行性是：&lt;strong&gt;树结构的序列化和反序列化是一一对应的&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;</description>
    </item>
    <item>
      <title>4.2 面试题</title>
      <link>https://kingye.me/study-algs/docs/appendix/interview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/appendix/interview/</guid>
      <description>&lt;h1 id=&#34;算法面试题&#34;&gt;&#xA;  算法面试题&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%97%e6%b3%95%e9%9d%a2%e8%af%95%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;基础题&#34;&gt;&#xA;  基础题&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;进阶题&#34;&gt;&#xA;  进阶题&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9b%e9%98%b6%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>KMP</title>
      <link>https://kingye.me/study-algs/docs/advanced/common/kmp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/advanced/common/kmp/</guid>
      <description>&lt;h1 id=&#34;kmp&#34;&gt;&#xA;  KMP&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#kmp&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;KMP 是用来找字符串匹配的&lt;/p&gt;&#xA;&lt;p&gt;KMP 的时间复杂度是 O (m + n)&lt;/p&gt;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  参考&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/21923021&#34;&gt;如何更好地理解和掌握 KMP 算法？&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/83334559&#34;&gt;KMP 算法详解&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.inf.hs-flensburg.de/lang/algorithmen/pattern/kmpen.htm&#34;&gt;Knuth-Morris-Pratt algorithm&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/112861530&#34;&gt;KMP：花 48 小时看懂了 KMP，想让你在 48 分钟内看懂&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>布隆过滤器</title>
      <link>https://kingye.me/study-algs/docs/advanced/common/bloom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/advanced/common/bloom/</guid>
      <description>&lt;h1 id=&#34;布隆过滤器httpswwwwikiwandcomzh-cne5b883e99a86e8bf87e6bba4e599a8&#34;&gt;&#xA;  &lt;a href=&#34;https://www.wikiwand.com/zh-cn/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8&#34;&gt;布隆过滤器&lt;/a&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8httpswwwwikiwandcomzh-cne5b883e99a86e8bf87e6bba4e599a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。&#xA;它实际上是一个&lt;strong&gt;很长的二进制向量&lt;/strong&gt;和&lt;strong&gt;一系列随机映射函数&lt;/strong&gt;。&#xA;布隆过滤器可以用于检索一个元素是否在一个集合中。&#xA;它的优点是&lt;strong&gt;空间效率&lt;/strong&gt;和&lt;strong&gt;查询时间&lt;/strong&gt;都比一般的算法要好的多，&#xA;缺点是有一定的&lt;strong&gt;误识别率&lt;/strong&gt;和&lt;strong&gt;删除困难&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;解决：&#xA;网页 URL 去重、垃圾邮件识别、大集合中重复元素的判断和缓存穿透等问题&lt;/p&gt;&#xA;&lt;p&gt;本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你&#xA;某样东西&lt;strong&gt;一定不存在&lt;/strong&gt;或者&lt;strong&gt;可能存在&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。&lt;/p&gt;&#xA;&lt;h2 id=&#34;hashmap-的问题&#34;&gt;&#xA;  HashMap 的问题&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hashmap-%e7%9a%84%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能&lt;strong&gt;一次性读进内存&lt;/strong&gt;构建 HashMap 的时候，也会存在问题。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;布隆过滤器的原理&#34;&gt;&#xA;  布隆过滤器的原理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8%e7%9a%84%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;当一个元素被加入集合时，通过 K 个&lt;a href=&#34;https://www.wikiwand.com/zh-cn/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0&#34;&gt;散列函数&lt;/a&gt;将这个元素映射成一个位&lt;a href=&#34;https://www.wikiwand.com/zh-cn/%E6%95%B0%E7%BB%84&#34; title=&#34;数组&#34;&gt;数组&lt;/a&gt;中的 K 个点，把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;应用&#34;&gt;&#xA;  应用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ba%94%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;在大数据场景应用比较多，比如 Hbase 中使用它去判断数据是否在磁盘上。&lt;/p&gt;&#xA;&lt;p&gt;还有在爬虫场景判断 url 是否已经被爬取过。&lt;/p&gt;&#xA;&lt;h3 id=&#34;在缓存之前在加一层-bloomfilter&#34;&gt;&#xA;  在缓存之前在加一层 BloomFilter&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9c%a8%e7%bc%93%e5%ad%98%e4%b9%8b%e5%89%8d%e5%9c%a8%e5%8a%a0%e4%b8%80%e5%b1%82-bloomfilter&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;</description>
    </item>
    <item>
      <title>递归</title>
      <link>https://kingye.me/study-algs/docs/basic/thought/recursive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/basic/thought/recursive/</guid>
      <description>&lt;h1 id=&#34;递归&#34;&gt;&#xA;  递归&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%92%e5%bd%92&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;参考&#34;&gt;&#xA;  参考&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://lyl0724.github.io/2020/01/25/1/&#34;&gt;三道题套路解决递归问题&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>4.3 关注项目</title>
      <link>https://kingye.me/study-algs/docs/appendix/attention/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/appendix/attention/</guid>
      <description>&lt;h1 id=&#34;关注项目&#34;&gt;&#xA;  关注项目&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b3%e6%b3%a8%e9%a1%b9%e7%9b%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;</description>
    </item>
    <item>
      <title>54. 螺旋矩阵</title>
      <link>https://kingye.me/study-algs/docs/advanced/leetcode/0/54/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/advanced/leetcode/0/54/</guid>
      <description>&lt;h1 id=&#34;螺旋矩阵&#34;&gt;&#xA;  螺旋矩阵&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%9e%ba%e6%97%8b%e7%9f%a9%e9%98%b5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目httpsleetcode-cncomproblemsspiral-matrix&#34;&gt;&#xA;  &lt;a href=&#34;https://leetcode-cn.com/problems/spiral-matrix&#34;&gt;题目&lt;/a&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemsspiral-matrix&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-0&#34; checked=&#34;checked&#34; /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-0&#34;&gt;中文&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;给定一个包含  m x n  个元素的矩阵（m 行，n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。&lt;/p&gt;&#xA;&lt;p&gt;示例  1:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入:&#xA;[&#xA; [ 1, 2, 3 ],&#xA; [ 4, 5, 6 ],&#xA; [ 7, 8, 9 ]&#xA;]&#xA;输出: [1,2,3,6,9,8,7,4,5]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例  2:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入:&#xA;[&#xA;  [1, 2, 3, 4],&#xA;  [5, 6, 7, 8],&#xA;  [9,10,11,12]&#xA;]&#xA;输出: [1,2,3,4,8,12,11,10,9,5,6,7]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-1&#34;  /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-1&#34;&gt;English&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.&lt;/p&gt;</description>
    </item>
    <item>
      <title>71. 简化路径</title>
      <link>https://kingye.me/study-algs/docs/advanced/leetcode/0/71/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/advanced/leetcode/0/71/</guid>
      <description>&lt;h1 id=&#34;模板&#34;&gt;&#xA;  模板&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e6%9d%bf&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目httpsleetcode-cncomproblemssimplify-path&#34;&gt;&#xA;  &lt;a href=&#34;https://leetcode-cn.com/problems/simplify-path/&#34;&gt;题目&lt;/a&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemssimplify-path&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-0&#34; checked=&#34;checked&#34; /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-0&#34;&gt;中文&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。&lt;/p&gt;&#xA;&lt;p&gt;在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..）  表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix 中的绝对路径 vs 相对路径&lt;/p&gt;&#xA;&lt;p&gt;请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。&lt;/p&gt;&#xA;&lt;p&gt;示例 1：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入：&amp;#34;/home/&amp;#34;&#xA;输出：&amp;#34;/home&amp;#34;&#xA;解释：注意，最后一个目录名后面没有斜杠。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例 2：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入：&amp;#34;/../&amp;#34;&#xA;输出：&amp;#34;/&amp;#34;&#xA;解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例 3：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入：&amp;#34;/home//foo/&amp;#34;&#xA;输出：&amp;#34;/home/foo&amp;#34;&#xA;解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例 4：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入：&amp;#34;/a/./b/../../c/&amp;#34;&#xA;输出：&amp;#34;/c&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例 5：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入：&amp;#34;/a/../../b/../c//.//&amp;#34;&#xA;输出：&amp;#34;/c&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例 6：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入：&amp;#34;/a//b////c/d//././/..&amp;#34;&#xA;输出：&amp;#34;/a/b/c&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-1&#34;  /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-1&#34;&gt;English&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path.&lt;/p&gt;&#xA;&lt;p&gt;In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level.&lt;/p&gt;</description>
    </item>
    <item>
      <title>110. 平衡二叉树</title>
      <link>https://kingye.me/study-algs/docs/advanced/leetcode/1/110/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/advanced/leetcode/1/110/</guid>
      <description>&lt;h1 id=&#34;平衡二叉树&#34;&gt;&#xA;  平衡二叉树&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%a0%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目httpsleetcode-cncomproblemsbalanced-binary-tree&#34;&gt;&#xA;  &lt;a href=&#34;https://leetcode-cn.com/problems/balanced-binary-tree/&#34;&gt;题目&lt;/a&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemsbalanced-binary-tree&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-0&#34; checked=&#34;checked&#34; /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-0&#34;&gt;中文&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;/p&gt;&#xA;&lt;p&gt;本题中，一棵高度平衡二叉树定义为：&lt;/p&gt;&#xA;&lt;p&gt;一个二叉树每个节点   的左右两个子树的高度差的绝对值不超过 1。&lt;/p&gt;&#xA;&lt;p&gt;示例 1:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;给定二叉树 [3,9,20,null,null,15,7]&#xA;&#xA;    3&#xA;   / \&#xA;  9  20&#xA;    /  \&#xA;   15   7&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;返回 true 。&lt;/p&gt;&#xA;&lt;p&gt;示例 2:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;给定二叉树 [1,2,2,3,3,null,null,4,4]&#xA;&#xA;       1&#xA;      / \&#xA;     2   2&#xA;    / \&#xA;   3   3&#xA;  / \&#xA; 4   4&#xA;返回 false 。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-1&#34;  /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-1&#34;&gt;English&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;Given a binary tree, determine if it is height-balanced.&lt;/p&gt;&#xA;&lt;p&gt;For this problem, a height-balanced binary tree is defined as:&lt;/p&gt;&#xA;&lt;p&gt;a binary tree in which the left and right subtrees of every node differ in height by no more than 1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>146. LRU 缓存机制</title>
      <link>https://kingye.me/study-algs/docs/advanced/leetcode/1/146/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/advanced/leetcode/1/146/</guid>
      <description>&lt;h1 id=&#34;lru-缓存机制&#34;&gt;&#xA;  LRU 缓存机制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#lru-%e7%bc%93%e5%ad%98%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目httpsleetcode-cncomproblemslru-cache&#34;&gt;&#xA;  &lt;a href=&#34;https://leetcode-cn.com/problems/lru-cache&#34;&gt;题目&lt;/a&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemslru-cache&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-0&#34; checked=&#34;checked&#34; /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-0&#34;&gt;中文&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;运用你所掌握的数据结构，设计和实现一个 &lt;a href=&#34;https://baike.baidu.com/item/LRU&#34;&gt;LRU (最近最少使用)&lt;/a&gt; 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。&lt;/p&gt;&#xA;&lt;p&gt;获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。&#xA;写入数据 put(key, value) - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥 / 数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。&lt;/p&gt;&#xA;&lt;p&gt;进阶:&lt;/p&gt;&#xA;&lt;p&gt;你是否可以在  &lt;code&gt;O(1)&lt;/code&gt; 时间复杂度内完成这两种操作？&lt;/p&gt;&#xA;&lt;p&gt;示例:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );&#xA;&#xA;cache.put(1, 1);&#xA;cache.put(2, 2);&#xA;cache.get(1);       // 返回  1&#xA;cache.put(3, 3);    // 该操作会使得密钥 2 作废&#xA;cache.get(2);       // 返回 -1 (未找到)&#xA;cache.put(4, 4);    // 该操作会使得密钥 1 作废&#xA;cache.get(1);       // 返回 -1 (未找到)&#xA;cache.get(3);       // 返回  3&#xA;cache.get(4);       // 返回  4&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-1&#34;  /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-1&#34;&gt;English&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;Design and implement a data structure for &lt;a href=&#34;https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU&#34;&gt;Least Recently Used (LRU)&lt;/a&gt; cache. It should support the following operations: get and put.&lt;/p&gt;</description>
    </item>
    <item>
      <title>206. 反转链表</title>
      <link>https://kingye.me/study-algs/docs/advanced/leetcode/2/206/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/advanced/leetcode/2/206/</guid>
      <description>&lt;h1 id=&#34;反转链表&#34;&gt;&#xA;  反转链表&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目httpsleetcode-cncomproblemsreverse-linked-list&#34;&gt;&#xA;  &lt;a href=&#34;https://leetcode-cn.com/problems/reverse-linked-list/&#34;&gt;题目&lt;/a&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemsreverse-linked-list&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-0&#34; checked=&#34;checked&#34; /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-0&#34;&gt;中文&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。&lt;/p&gt;&#xA;&lt;p&gt;示例 1：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;输入：head &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;1,2,3,4,5&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;输出：&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;5,4,3,2,1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;示例 2：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;输入：head &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;1,2&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;输出：&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;2,1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;示例 3：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;输入：head &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;输出：&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;提示：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;链表中节点的数目范围是 &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;0, 5000&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-5000 &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Node.val &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5000&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？&lt;/p&gt;&#xA;&lt;/div&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-1&#34;  /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-1&#34;&gt;English&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;Given the head of a singly linked list, reverse the list, and return the reversed list.&lt;/p&gt;&#xA;&lt;p&gt;Example 1:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: head = [1,2,3,4,5]&#xA;Output: [5,4,3,2,1]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Example 2:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: head = [1,2]&#xA;Output: [2,1]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Example 3:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Input: head = []&#xA;Output: []&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Constraints:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;The number of nodes in the list is the range [0, 5000].&#xA;-5000 &amp;lt;= Node.val &amp;lt;= 5000&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?&lt;/p&gt;</description>
    </item>
    <item>
      <title>671. 二叉树中第二小的节点</title>
      <link>https://kingye.me/study-algs/docs/advanced/leetcode/6/671/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kingye.me/study-algs/docs/advanced/leetcode/6/671/</guid>
      <description>&lt;h1 id=&#34;二叉树中第二小的节点&#34;&gt;&#xA;  二叉树中第二小的节点&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8c%e5%8f%89%e6%a0%91%e4%b8%ad%e7%ac%ac%e4%ba%8c%e5%b0%8f%e7%9a%84%e8%8a%82%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;题目httpsleetcode-cncomproblemssecond-minimum-node-in-a-binary-tree&#34;&gt;&#xA;  &lt;a href=&#34;https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/&#34;&gt;题目&lt;/a&gt;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%98%e7%9b%aehttpsleetcode-cncomproblemssecond-minimum-node-in-a-binary-tree&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;book-tabs&#34;&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-0&#34; checked=&#34;checked&#34; /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-0&#34;&gt;中文&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为  2  或  0。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。&lt;/p&gt;&#xA;&lt;p&gt;给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。&lt;/p&gt;&#xA;&lt;p&gt;示例 1:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入:&#xA;    2&#xA;   / \&#xA;  2   5&#xA;     / \&#xA;    5   7&#xA;&#xA;输出: 5&#xA;说明: 最小的值是 2 ，第二小的值是 5  。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例 2:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入:&#xA;    2&#xA;   / \&#xA;  2   2&#xA;&#xA;输出: -1&#xA;说明: 最小的值是 2, 但是不存在第二小的值。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;input type=&#34;radio&#34; class=&#34;toggle&#34; name=&#34;tabs-leetcode-problem&#34; id=&#34;tabs-leetcode-problem-1&#34;  /&gt;&#xA;  &lt;label for=&#34;tabs-leetcode-problem-1&#34;&gt;English&lt;/label&gt;&#xA;  &lt;div class=&#34;book-tabs-content markdown-inner&#34;&gt;&lt;p&gt;Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node&amp;rsquo;s value is the smaller value among its two sub-nodes. More formally, the property root.val = min(root.left.val, root.right.val) always holds.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
